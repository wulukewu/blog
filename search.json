[{"title":"在 macOS 使用 <bits/stdc++.h>","url":"/blog/2025/07/bits-std-on-mac/","content":"Steps\ncd /usr/local/includemkdir bitscd bitsvim stdc++.h\n在 stdc++.h 的檔案當中寫入下列資訊：\n// C++ includes used for precompiling -*- C++ -*-// Copyright (C) 2003-2014 Free Software Foundation, Inc.//// This file is part of the GNU ISO C++ Library.  This library is free// software; you can redistribute it and/or modify it under the// terms of the GNU General Public License as published by the// Free Software Foundation; either version 3, or (at your option)// any later version.// This library is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the// GNU General Public License for more details.// Under Section 7 of GPL version 3, you are granted additional// permissions described in the GCC Runtime Library Exception, version// 3.1, as published by the Free Software Foundation.// You should have received a copy of the GNU General Public License and// a copy of the GCC Runtime Library Exception along with this program;// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see// &lt;http://www.gnu.org/licenses/&gt;./** @file stdc++.h *  This is an implementation file for a precompiled header. */// 17.4.1.2 Headers// C#ifndef _GLIBCXX_NO_ASSERT#include &lt;cassert&gt;#endif#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;ciso646&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;cmath&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#if __cplusplus &gt;= 201103L#include &lt;ccomplex&gt;#include &lt;cfenv&gt;#include &lt;cinttypes&gt;#include &lt;cstdbool&gt;#include &lt;cstdint&gt;#include &lt;ctgmath&gt;#include &lt;cwchar&gt;#include &lt;cwctype&gt;#endif// C++#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;complex&gt;#include &lt;deque&gt;#include &lt;exception&gt;#include &lt;fstream&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;ios&gt;#include &lt;iosfwd&gt;#include &lt;iostream&gt;#include &lt;istream&gt;#include &lt;iterator&gt;#include &lt;limits&gt;#include &lt;list&gt;#include &lt;locale&gt;#include &lt;map&gt;#include &lt;memory&gt;#include &lt;new&gt;#include &lt;numeric&gt;#include &lt;ostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;stdexcept&gt;#include &lt;streambuf&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;#include &lt;utility&gt;#include &lt;valarray&gt;#include &lt;vector&gt;#if __cplusplus &gt;= 201103L#include &lt;array&gt;#include &lt;atomic&gt;#include &lt;chrono&gt;#include &lt;condition_variable&gt;#include &lt;forward_list&gt;#include &lt;future&gt;#include &lt;initializer_list&gt;#include &lt;mutex&gt;#include &lt;random&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;scoped_allocator&gt;#include &lt;system_error&gt;#include &lt;thread&gt;#include &lt;tuple&gt;#include &lt;typeindex&gt;#include &lt;type_traits&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#endif\n再來 #include &lt;bits/stdc++.h&gt; 就能順利運行了\nReferences\nmacOS\n下使用 &lt;bits/stdc++.h&gt;\n"},{"title":"Codeforces 暑期特訓：我想成為演算法大師 - Week 1","url":"/blog/2025/07/codeforces-algo-master-week-01/","content":"\nFrom LI2\nContests Group\n\nContest 09. Prefix sums\nand countings\n\nContest\nProblems\n\nC. Rectangle Sum\n\nProblem: C.\nRectangle Sum\nSolution: GitHub\nCode\n\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){    int n, m, k;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    vector &lt; vector &lt; int &gt; &gt; dp(n+1, vector &lt; int &gt; (m+1, 0));    for(int i=1; i&lt;=n; i++){        for(int j=1; j&lt;=m; j++){            cin &gt;&gt; dp[i][j];        }    }    for(int i=1; i&lt;=n; i++){        for(int j=1; j&lt;=m; j++){            dp[i][j] += dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1];        }    }    // for(int i=0; i&lt;=n; i++){    //     for(int j=0; j&lt;=m; j++){    //         cout &lt;&lt; dp[i][j] &lt;&lt; ' ';    //     }    //     cout &lt;&lt; endl;    // }    int x1, y1, x2 ,y2;    for(int i=0; i&lt;k; i++){        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;        cout &lt;&lt; dp[x2][y2] - dp[x2][y1-1] - dp[x1-1][y2] + dp[x1-1][y1-1] &lt;&lt; endl;    }}\nF. Counting Sort\n\nProblem: F.\nCounting Sort\nSolution: GitHub\nCode\n\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){    vector &lt; int &gt; arr;    int n;    while(cin &gt;&gt; n){        arr.push_back(n);    }    n = arr.size();    vector &lt; int &gt; brr(101, 0);    for(int i=0; i&lt;n; i++){        brr[arr[i]]++;    }    for(int i=0; i&lt;=100; i++){        for(int j=0; j&lt;brr[i]; j++){            cout &lt;&lt; i &lt;&lt; ' ';        }    }}\nG. Haybale Stacking\n\nProblem: G.\nHaybale Stacking\nSolution: GitHub\nCode\n\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){    int n, k;    cin &gt;&gt; n &gt;&gt; k;    vector &lt; int &gt; arr(n, 0);    int a, b;    for(int i=0; i&lt;k; i++){        cin &gt;&gt; a &gt;&gt; b;        arr[a-1]++;        arr[b]--;    }    for(int i=1; i&lt;n; i++){        arr[i] += arr[i-1];    }    for(int i=0; i&lt;n; i++){        cout &lt;&lt; arr[i] &lt;&lt; ' ';    }}\nContest 10. Sorting\n\nContest\nProblems\n\nC. Sorting halves\n\nProblem: C.\nSorting halves\nSolution: GitHub\nCode\n\n#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;vector&gt;// #include &lt;algorithm&gt;using namespace std;int main(){    ifstream fcin(\"input.txt\");    ofstream fcout(\"output.txt\");    int n;    // cin &gt;&gt; n;    fcin &gt;&gt; n;    vector &lt; int &gt; arr(n);    for(int i=0; i&lt;n; i++){        // cin &gt;&gt; arr[i];        fcin &gt;&gt; arr[i];    }    sort(arr.begin(), arr.begin() + n/2);    // sort(arr.begin() + n/2, arr.end(), greater&lt;int&gt;());    sort(arr.begin() + n/2, arr.end(), [](int a, int b){        return a &gt; b;    });    for(int i=0; i&lt;n; i++){        // cout &lt;&lt; arr[i] &lt;&lt; ' ';        fcout &lt;&lt; arr[i] &lt;&lt; ' ';    }}\nD. Merge Lists\n\nProblem: D.\nMerge Lists\nSolution: GitHub\nCode\n\n#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;vector&gt;// #include &lt;sstream&gt;using namespace std;int main(){    ifstream fcin(\"input.txt\");    ofstream fcout(\"output.txt\");    int n;    string line;    vector &lt; int &gt; arr;    vector &lt; int &gt; brr;    getline(fcin, line);    stringstream ss(line);    while(ss &gt;&gt; n){        arr.push_back(n);    }    getline(fcin, line);    ss.clear();    ss.str(line);    while(ss &gt;&gt; n){        brr.push_back(n);    }    // for(int i: arr){    //     cout &lt;&lt; i &lt;&lt; ' ';    // }    // cout &lt;&lt; endl;    // for(int i: brr){    //     cout &lt;&lt; i &lt;&lt; ' ';    // }    // cout &lt;&lt; endl;    vector &lt; int &gt; crr;    int n1 = arr.size();    int n2 = brr.size();    int j = 0;    for(int i=0; i&lt;n1; i++){        while(arr[i]&gt;brr[j] and j&lt;n2){            crr.push_back(brr[j]);            j++;        }        crr.push_back(arr[i]);    }    while(j&lt;n2){        crr.push_back(brr[j]);        j++;    }    for(int i: crr){        fcout &lt;&lt; i &lt;&lt; ' ';    }}\nF. Sorting. Stone method.\n\nProblem: F.\nSorting. Stone method.\nSolution: GitHub\nCode\n\n#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;vector&gt;using namespace std;int main(){    ifstream fcin(\"input.txt\");    ofstream fcout(\"output.txt\");    int n;    fcin &gt;&gt; n;    vector &lt; int &gt; arr(n);    for(int i=0; i&lt;n; i++){        fcin &gt;&gt; arr[i];    }    bool det = true;    for(int i=n-1; i&gt;0; i--){        for(int j=0; j&lt;i; j++){            if(arr[j]&gt;arr[j+1]){                swap(arr[j], arr[j+1]);                det = false;                for(int k: arr){                    fcout &lt;&lt; k &lt;&lt; ' ';                }                fcout &lt;&lt; endl;            }        }    }    if(det){        fcout &lt;&lt; 0;    }}\nK. Olympiad Results\n\nProblem: K.\nOlympiad Results\nSolution: GitHub\nCode\n\n#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;vector&gt;using namespace std;int main(){    ifstream fcin(\"input.txt\");    ofstream fcout(\"output.txt\");    int n;    fcin &gt;&gt; n;    int a, b;    vector &lt; pair &lt; int, int &gt; &gt; arr(n);    for(int i=0; i&lt;n; i++){        fcin &gt;&gt; a &gt;&gt; b;        arr[i] = make_pair(a, b);    }    sort(arr.begin(), arr.end(), [](pair &lt; int, int &gt; p1, pair &lt; int, int &gt; p2){        if(p1.second == p2.second){            return p1.first &lt; p2.first;        }else{            return p1.second &gt; p2.second;        }    });    for(auto i: arr){        fcout &lt;&lt; i.first &lt;&lt; ' ' &lt;&lt; i.second &lt;&lt; endl;    }}\n","tags":["algorithm","codeforces","competitive-programming"]},{"title":"Codeforces 暑期特訓：我想成為演算法大師 - Week 2","url":"/blog/2025/07/codeforces-algo-master-week-02/","content":"\nFrom LI2\nContests Group\n\nContest 11. Binary Search\n\nContest\nProblems\n\nC. Street with monuments\n\nProblem: C.\nStreet with monuments\nSolution: GitHub\nCode\n\n用 upper_bound() 找第一個大於目標\ntarget=d[i]+r 的元素\nvoid solve() {    int n, r;    cin &gt;&gt; n &gt;&gt; r;    vector&lt;int&gt;d(n);    FOR(i, 0, n) cin &gt;&gt; d[i];    int ans = 0;    FOR(i, 0, n){        auto it_upper = upper_bound(ALL(d), d[i]+r);        ans += d.end()-it_upper;    }    cout &lt;&lt; ans &lt;&lt; endl;}\n* 記得開 long long\nE. Diplomas\n\nProblem: E.\nDiplomas\nSolution: GitHub\nCode\n\n如果答案邊長是 ans ，那麼邊長為 ans+1\n也會成立，所以目標是用 binary_search 找到最小的邊長\nvoid solve() {    int w, h, n;    cin &gt;&gt; w &gt;&gt; h &gt;&gt; n;    int l = 1;    int r = max(w, h) * n;    int ans = r;    while(l&lt;=r){        int mid = l + (r-l)/2;        int cnt = ((int)mid/w) * ((int)mid/h);        if(cnt &gt;= n){            ans = mid;            r = mid - 1;        }else{            l = mid + 1;        }    }    cout &lt;&lt; ans &lt;&lt; endl;}\nJ. Forest Clearing\n\nProblem: J.\nForest Clearing\nSolution: GitHub\nCode\n\n用 binary_search 找最少能砍完的天數\n記得開 long long ，其中\ny += a * (mid - mid / k); 及\ny += b * (mid - mid / m); 可能會卡在 WA，因為 109 × 1018 = 1027\n會溢位。\nvoid solve() {    int a, k, b, m, x;    cin &gt;&gt; a &gt;&gt; k &gt;&gt; b &gt;&gt; m &gt;&gt; x;    int l = 1;    int r = 2 * x;    int ans = r;    while(l&lt;=r){        int mid = l + (r-l) / 2;        int y = 0;        if((mid - mid / k) &gt; x / a){            y = x + 1;        }else{            y += a * (mid - mid / k);        }        if((mid - mid / m) &gt; x / b){            y = x + 1;        }else{            y += b * (mid - mid / m);        }        if(y&gt;=x){            r = mid - 1;            ans = mid;        }else{            l = mid + 1;        }    }    cout &lt;&lt; ans &lt;&lt; endl;}\nContest 13. Recursion\n\nContest\nProblems\n\nC. Transformations\n\nProblem: C.\nTransformations\nSolution: GitHub\nCode\n\nBFS 從 b 每次做 -1 或 /2\n的動作推到 a 其中 queue q 是存 BFS\n路徑的節點，再用 map prev 、 op\n存經過每個數字的下個點及做的動作，最後 now 從\na 跑到 b，再將答案的等式做出來。\nvoid solve() {    int a, b;    cin &gt;&gt; a &gt;&gt; b;    queue &lt; int &gt; q;    map &lt; int, int &gt; prev;    map &lt; int, char &gt; op;    q.push(b);    prev[b] = 0;    op[b] = ' ';    while(!q.empty()){        int c = q.front();        q.pop();        if(c==a) break;        int next = c - 1;        if(next&gt;=a and prev.find(next)==prev.end()){            q.push(next);            prev[next] = c;            op[next] = '+';        }        if(c%2==0){            next = c / 2;            if(next&gt;=a and prev.find(next)==prev.end()){                q.push(next);                prev[next] = c;                op[next] = '*';            }        }    }    string ans = to_string(a);    int now = a;    while(now!=b){        if(op[now]=='+'){            ans = \"(\" + ans + \" + 1)\";        }else{            ans = ans + \" * 2\";        }        now = prev[now];    }    cout &lt;&lt; b &lt;&lt; \" = \" &lt;&lt; ans &lt;&lt; endl;}\nE. Weighing\n\nProblem: E.\nWeighing\nSolution: GitHub\nCode\n\n每個砝碼 (w[i]) 有三種選擇：\n\n放左邊 -w[i]\n放右邊 +w[i]\n不放 +0\n\n\nm\n為砝碼總重，如果將所有砝碼都放在同一邊，陣列左右都設成m，重量不會超過\n初始化二維 dp ，第一行 idx=0\n什麼都不放，所以在平衝狀態 dp[0][m] 為\ntrue\n對於每行 dp[i][j] 為 true\n的狀態，分別考慮當前砝碼做三個動作後的平衡狀態（寫入\ndp[i+1] 列）\n迴圈跑完後，最後看若將重量為 k\n的砝碼放在右邊，是不是還存在這樣的狀況\n\nvoid solve() {    int k, n;    cin &gt;&gt; k &gt;&gt; n;    int m = 0;    vector &lt; int &gt; w(n);    FOR(i, 0, n){        cin &gt;&gt; w[i];        m += w[i];    }    vector &lt; vector &lt; bool &gt; &gt; dp(n+1, vector &lt; bool &gt; (2*m+1, false));    dp[0][m] = true;    FOR(i, 0, n){        int current = w[i];        FOR(j, 0, 2*m+1){            if(dp[i][j]){                dp[i+1][j] = true;                int idx_left = j - current;                if(idx_left &gt;= 0){                    dp[i+1][idx_left] = true;                }                int idx_right = j + current;                if(idx_right &lt; 2*m+1){                    dp[i+1][idx_right] = true;                }            }        }    }    if(k+m&gt;=0 and k+m&lt;2*m+1 and dp[n][k+m]){        cout &lt;&lt; \"YES\" &lt;&lt; endl;    }else{        cout &lt;&lt; \"NO\" &lt;&lt; endl;    }}\nJ. Coins\n\nProblem: J.\nCoins\nSolution: GitHub\nCode\n\n用 dfs 遍歷每個可能\nvoid solve() {    int n, m;    cin &gt;&gt; n &gt;&gt; m;    int a;    set &lt; int &gt; aset;    FOR(i, 0, m){        cin &gt;&gt; a;        if(aset.find(a)==aset.end()){            aset.insert(a);        }    }    vector &lt; int &gt; arr;    for(int i: aset){        arr.PB(i);    }    int total = 0;    FOR(i, 0, m) total += arr[i];    total *= 2;    if(n&gt;total){        cout &lt;&lt; -1 &lt;&lt; endl;        return;    }    vector &lt; int &gt; v(m, 0);    int ans_cnt = 2*m+1;    vector &lt; int &gt; ans(m, 0);    auto dfs = [&amp;](int rem, int idx, int coin_cnt, auto&amp;&amp; self) -&gt; void {        if(idx&gt;=m){            if(rem==0 and coin_cnt &lt; ans_cnt){                ans = v;            }            return;        }else if(rem&lt;0){            return;        }        if(v[idx]&lt;2){            v[idx] += 1;            self(rem-arr[idx], idx, coin_cnt+1, self);            v[idx] -= 1;        }        self(rem, idx+1, coin_cnt, self);    };    dfs(n, 0, 0, dfs);    int k = 0;    FOR(i, 0, m){        k += ans[i];    }    cout &lt;&lt; k &lt;&lt; endl;    if(k&gt;0){        vector &lt; int &gt; ans_sort;        FOR(i, 0, m){            FOR(j, 0, ans[i]){                ans_sort.PB(arr[i]);            }        }            sort(ALL(ans_sort));            for(int i: ans_sort){            cout &lt;&lt; i &lt;&lt; ' ';        }        cout &lt;&lt; endl;    }}\nL. Peaceful Queens\n\nProblem: L.\nPeaceful Queens\nSolution: GitHub\nCode\n\n\n用 dfs 做下去，每層往上確認能不能放進去，走到底之後再存到\nans 的陣列裡\n用三個一維陣列 visit 、 diag_pos 、\ndiag_neg 來存直線跟對角能不能放的狀態\n\nvoid solve() {    int n;    cin &gt;&gt; n;    vector &lt; vector &lt; int &gt; &gt; ans;    vector &lt; bool &gt; visit(n, false);    vector &lt; bool &gt; diag_pos(n, false);    vector &lt; bool &gt; diag_neg(n, false);    auto dfs = [&amp;](vector &lt; int &gt; v, auto&amp;&amp; self) -&gt; void {        int m = v.size();        if(m==n){            ans.push_back(v);            return;        }        FOR(i, 0, n){            if(!visit[i] and !diag_pos[m-i+n-1] and !diag_neg[m+i]){                v.push_back(i);                visit[i] = true;                diag_pos[m-i+n-1] = true;                diag_neg[m+i] = true;                self(v, self);                v.pop_back();                visit[i] = false;                diag_pos[m-i+n-1] = false;                diag_neg[m+i] = false;            }        }    };    dfs(vector &lt; int &gt;(), dfs);    for(auto i: ans){        cout &lt;&lt; \"(\";        FOR(j, 0, n){            cout &lt;&lt; i[j]+1;            if(j&lt;n-1){                cout &lt;&lt; \",\";            }        }        cout &lt;&lt; \")\" &lt;&lt; endl;    }}\n","tags":["algorithm","codeforces","competitive-programming"]},{"title":"Codeforces 暑期特訓：我想成為演算法大師 - Week 3","url":"/blog/2025/07/codeforces-algo-master-week-03/","content":"\nFrom LI2\nContests Group\n\nContest 11. Binary Search\n\nContest\nProblems\n\nM. Sorting fractions\n\nProblem: M.\nSorting fractions\nSolution: GitHub Code\n\nContest 15. Two Pointers\n\nContest\nProblems\n\nC. Stylish clothes\n\nProblem: C.\nStylish clothes\nSolution: GitHub\nCode\n\n對於每個顏色，用 lower_bound\n找大於等於的最小顏色，判斷是不是更小的可能。\nvoid solve() {    int n1, n2, n3, n4;    cin &gt;&gt; n1;    vector &lt; int &gt; a1(n1);    FOR(i, 0, n1) cin &gt;&gt; a1[i];    cin &gt;&gt; n2;    vector &lt; int &gt; a2(n2);    FOR(i, 0, n2) cin &gt;&gt; a2[i];    cin &gt;&gt; n3;    vector &lt; int &gt; a3(n3);    FOR(i, 0, n3) cin &gt;&gt; a3[i];    cin &gt;&gt; n4;    vector &lt; int &gt; a4(n4);    FOR(i, 0, n4) cin &gt;&gt; a4[i];    sort(ALL(a1));    sort(ALL(a2));    sort(ALL(a3));    sort(ALL(a4));    set &lt; int &gt; s;    FOR(i, 0, n1) s.insert(a1[i]);    FOR(i, 0, n2) s.insert(a2[i]);    FOR(i, 0, n3) s.insert(a3[i]);    FOR(i, 0, n4) s.insert(a4[i]);    int colors_cnt = s.size();    vector &lt; int &gt; brr;    for(int i: s) brr.PB(i);    int ans_diff = MOD;    vector &lt; int &gt; ans(4, -1);    for(int i: brr){        auto it1 = lower_bound(ALL(a1), i);        auto it2 = lower_bound(ALL(a2), i);        auto it3 = lower_bound(ALL(a3), i);        auto it4 = lower_bound(ALL(a4), i);        if(it1==a1.end() or it2==a2.end() or it3==a3.end() or it4==a4.end()) break;        int c1 = *it1;        int c2 = *it2;        int c3 = *it3;        int c4 = *it4;        vector &lt; int &gt; crr(4);        crr[0] = c1;        crr[1] = c2;        crr[2] = c3;        crr[3] = c4;        int diff = 0;        FOR(i, 0, 4){            FOR(j, i+1, 4){                diff = max(diff, abs(crr[i]-crr[j]));            }        }        if(diff&lt;ans_diff){            ans = crr;            ans_diff = diff;        }        if(ans_diff==0) break;    }    FOR(i, 0, 4){        cout &lt;&lt; ans[i] &lt;&lt; ' ';    }    cout &lt;&lt; endl;}\nG. Elves and Reindeer\n\nProblem: G.\nElves and Reindeer\nSolution: GitHub\nCode\n\nWA on test 2\nvoid solve() {    int m, n;    cin &gt;&gt; m &gt;&gt; n;    vector &lt; pair &lt; int, int &gt; &gt; arr(m);    FOR(i, 0, m){        cin &gt;&gt; arr[i].F;        arr[i].S = i+1;    }    int x;    set &lt; pair &lt; int, int &gt; &gt; brr;    FOR(i, 0, n){        cin &gt;&gt; x;        brr.insert(make_pair(x, i+1));    }    sort(ALL(arr));    vector &lt; pair &lt; int, pair &lt; int, int &gt; &gt; &gt; ans;    for(auto a: arr){        auto it1 = brr.lower_bound(make_pair(a.F, -1));        if(it1 == brr.begin()) continue;        it1--;        auto it2 = brr.upper_bound(make_pair(a.F, n+1));        if(it2 == brr.end()) continue;        pair &lt; int, int &gt; p1 = *it1;        pair &lt; int, int &gt; p2 = *it2;        ans.PB(make_pair(a.S, make_pair(p1.S, p2.S)));        brr.erase(it1);        brr.erase(it2);    }    cout &lt;&lt; ans.size() &lt;&lt; endl;    for(auto a: ans){        cout &lt;&lt; a.F &lt;&lt; ' ' &lt;&lt; a.S.F &lt;&lt; ' ' &lt;&lt; a.S.S &lt;&lt; endl;    }}\nContest 16. Linear Data\nStructures\n\nContest\nProblems\n\nC. Brackets\n\nProblem: C.\nBrackets\nSolution: GitHub\nCode\n\n用 stack 儲存左括號，並判斷是否能消去右括號\nvoid solve() {    string s;    cin &gt;&gt; s;    int ans = true;    stack &lt; char &gt; st;    for(char i: s){        if(i=='(' or i=='[' or i=='{'){            st.push(i);        }else if(i==')'){            if(st.size()&gt;0 and st.top()=='('){                st.pop();            }else{                ans = false;                break;            }        }else if(i==']'){            if(st.size()&gt;0 and st.top()=='['){                st.pop();            }else{                ans = false;                break;            }        }else if(i=='}'){            if(st.size()&gt;0 and st.top()=='{'){                st.pop();            }else{                ans = false;                break;            }        }    }    if(ans and st.size()==0){        cout &lt;&lt; \"YES\" &lt;&lt; endl;    }else{        cout &lt;&lt; \"NO\" &lt;&lt; endl;    }}\nH. Postfix Notation\n\nProblem: H.\nPostfix Notation\nSolution: GitHub\nCode\n\n用 stack 儲存數字，每次的符號提出最上面兩個數做運算再存回去\nvoid solve() {    stack &lt; int &gt; st;    int a, b;    char c;    while(cin &gt;&gt; c){        if('0'&lt;=c and c&lt;='9'){            st.push(c-'0');            continue;        }        b = st.top();        st.pop();        a = st.top();        st.pop();        if(c=='+'){            st.push(a+b);        }else if(c=='-'){            st.push(a-b);        }else if(c=='*'){            st.push(a*b);        }    }    cout &lt;&lt; st.top() &lt;&lt; endl;}\nM. Adjacency Lists\n\nProblem: M.\nAdjacency Lists\nSolution: GitHub\nCode\n\n建立大小為 n 的二維 vector\n，裡面存入每個點會連結到的其他點\nvoid solve() {    int n, m;    cin &gt;&gt; n &gt;&gt; m;    vector &lt; vector &lt; int &gt; &gt; v(n);    int a, b;    FOR(i, 0, m){        cin &gt;&gt; a &gt;&gt; b;        v[a-1].PB(b);        v[b-1].PB(a);    }    FOR(i, 0, n){        cout &lt;&lt; v[i].size() &lt;&lt; ' ';        for(int j: v[i]){            cout &lt;&lt; j &lt;&lt; ' ';        }        cout &lt;&lt; endl;    }}\nContest 17. Set and Map\n\nContest\nProblems\n\nB. Same values\n\nProblem: B.\nSame values\nSolution: GitHub\nCode\n\n先用 map 存所有出現的數字對應到的位置，再去找到位置後 iterator\n往前一格看\noid solve() {    int n;    cin &gt;&gt; n;    vector &lt; int &gt; arr(n);    FOR(i, 0, n) cin &gt;&gt; arr[i];    map &lt; int, vector &lt; int &gt; &gt; mp;    FOR(i, 0, n){        if(mp.find(arr[i])==mp.end()){            mp.insert(make_pair(arr[i], vector &lt; int &gt; (1, i)));        }else{            mp[arr[i]].PB(i);        }    }    FOR(i, 0, n){        auto it = lower_bound(ALL(mp[arr[i]]), i);        if(it==mp[arr[i]].begin()){            cout &lt;&lt; -1 &lt;&lt; ' ';        }else{            it--;            cout &lt;&lt; i-*it &lt;&lt; ' ';        }    }}\nG. Shooting\n\nProblem: G.\nShooting\nSolution: GitHub\nCode\n\n\n用 map 存每個人的總分，再印出來最高分的所有人\n這裡用了 name_set 及 name_vector\n來存名字的順序\n\nvoid solve() {    int n;    cin &gt;&gt; n;    map &lt; string, int &gt; mp;    set &lt; string &gt; name_set;    vector &lt; string &gt; name_vector;    string name;    int score;    FOR(i, 0, n){        cin &gt;&gt; name &gt;&gt; score;        if(mp.find(name)==mp.end()){            mp.insert(make_pair(name, score));        }else{            mp[name] += score;        }        if(name_set.find(name)==name_set.end()){            name_set.insert(name);            name_vector.PB(name);        }    }    int max_score = 0;    for(auto i: mp){        max_score = max(max_score, i.S);    }    cout &lt;&lt; max_score &lt;&lt; endl;    int cnt = 0;    for(string i: name_vector){        if(mp[i]==max_score){            if(cnt&gt;0) cout &lt;&lt; ',';            cout &lt;&lt; i;            cnt++;        }    }}\nL. Set 3\n\nProblem: L.\nSet 3\nSolution: GitHub\nCode\n\n做一個 set 按照題意照做，在 nearest 時用\nlower_bound 找到最接近的其中一個位置\nvoid solve() {    int n;    cin &gt;&gt; n;    set &lt; int &gt; s;    string op;    int x;    FOR(i, 0, n){        cin &gt;&gt; op &gt;&gt; x;        if(op==\"add\"){            if(s.find(x)==s.end()){                s.insert(x);                cout &lt;&lt; \"YES\" &lt;&lt; endl;            }else{                cout &lt;&lt; \"NO\" &lt;&lt; endl;            }        }else if(op==\"remove\"){            if(s.find(x)!=s.end()){                s.erase(x);                cout &lt;&lt; \"YES\" &lt;&lt; endl;            }else{                cout &lt;&lt; \"NO\" &lt;&lt; endl;            }        }else if(op==\"nearest\"){            if(s.empty()){                cout &lt;&lt; \"ERROR\" &lt;&lt; endl;                continue;            }            auto it = s.lower_bound(x);            int y = 0;            int z = LLONG_MAX;            if(it!=s.end()){                if(abs(*it-x)&lt;z){                    y = *it;                    z = abs(*it-x);                }else if(abs(*it-x)==z){                    y = max(y, *it);                }            }            if(it!=s.begin()){                it--;                if(abs(*it-x)&lt;z){                    y = *it;                    z = abs(*it-x);                }else if(abs(*it-x)==z){                    y = max(y, *it);                }            }            cout &lt;&lt; y &lt;&lt; endl;        }    }    stack &lt; int &gt; ans;    for(int i: s){        ans.push(i);    }    while(!ans.empty()){        cout &lt;&lt; ans.top() &lt;&lt; ' ';        ans.pop();    }}\n","tags":["algorithm","codeforces","competitive-programming"]},{"title":"Codeforces 暑期特訓：我想成為演算法大師 - Week 4","url":"/blog/2025/07/codeforces-algo-master-week-04/","content":"\nFrom LI2\nContests Group\n\nContest 19. Dynamic\nProgramming\n\nContest\nProblems\n\nC. Grasshoper-K\n\nProblem: C.\nGrasshoper-K\nSolution: GitHub\nCode\n\n每格的種數由前面 1~k 格加總\nvoid solve() {    int n, k;    cin &gt;&gt; n &gt;&gt; k;    vector &lt; int &gt; dp(n, 0);    dp[0] = 1;    FOR(i, 1, n){        FOR(j, 1, k+1){            if(i-j&gt;=0){                dp[i] += dp[i-j];            }        }    }    cout &lt;&lt; dp[n-1] &lt;&lt; endl;}\nE. Grasshopper and Money\n\nProblem: E.\nGrasshopper and Money\nSolution: GitHub\nCode\n\n\n解題過程是先用 dp 把最大值求出來，再讓 dp\n同時存著最大路徑時走過的點\n但是這個解法可能會 MLE，總共花了 86 MB（題目限制是 256 MB）\n\nvoid solve() {    int n, k;    cin &gt;&gt; n &gt;&gt; k;    vector &lt; int &gt; coins(n-2);    FOR(i, 0, n-2) cin &gt;&gt; coins[i];    vector &lt; pair &lt; int, vector &lt; int &gt; &gt; &gt; dp(n);    dp[0] = make_pair(0, vector &lt; int &gt;());    FOR(i, 1, n){        int max_coins = -INT_MAX;        int max_coins_idx = -1;        FOR(j, 1, k+1){            if(i-j&lt;0) break;            if(dp[i-j].F&gt;max_coins){                max_coins = dp[i-j].F;                max_coins_idx = i-j;            }        }        if(i&lt;n-1){            dp[i].F = max_coins + coins[i-1];        }else{            dp[i].F = max_coins;        }        vector &lt; int &gt; v = dp[max_coins_idx].S;        v.PB(max_coins_idx+1);        dp[i].S = v;    }    cout &lt;&lt; dp[n-1].F &lt;&lt; endl;    cout &lt;&lt; dp[n-1].S.size() &lt;&lt; endl;    for(int i: dp[n-1].S){        cout &lt;&lt; i &lt;&lt; ' ';    }    cout &lt;&lt; n &lt;&lt; endl;}\nJ. Milk in Bottles - K\n\nProblem: J.\nMilk in Bottles - K\nSolution: GitHub\nCode\n\n\n開一個一維 dp 陣列儲存不同 n\n對應到答案的子問題，在轉移狀態時對每個容量的瓶子去裝，找數量最小的出來\ndp[i] 表示 i\n的牛奶最少可以有幾瓶，所以此題所求即為 dp[n]\n另外用一個 last_bottles\n陣列表示在當前狀態下，選擇哪個瓶子所對應到的子問題，得出的答案數量會最小\n\nvoid solve() {    ifstream fcin(\"input.txt\");    ofstream fcout(\"output.txt\");    int n, k;    fcin &gt;&gt; n &gt;&gt; k;    vector &lt; int &gt; bottles(k);    FOR(i, 0, k) fcin &gt;&gt; bottles[i];    vector &lt; int &gt; dp(n+1, INT_MAX);    dp[0] = 0;    vector &lt; int &gt; last_bottles(n+1, 0);    FOR(i, 1, n+1){        for(int j: bottles){            if(dp[i-j]+1&lt;dp[i] and i-j&gt;=0 and dp[i-j]!=INT_MAX){                dp[i] = dp[i-j] + 1;                last_bottles[i] = j;            }        }    }    if(dp[n]==INT_MAX){        fcout &lt;&lt; -1 &lt;&lt; endl;    }else{        fcout &lt;&lt; dp[n] &lt;&lt; endl;        vector &lt; int &gt; ans;        int nn = n;        while(nn&gt;0){            int l = last_bottles[nn];            ans.PB(l);            nn -= l;        }        sort(ALL(ans));        for(int i: ans){            fcout &lt;&lt; i &lt;&lt; ' ';        }    }}\nL. Array Filling\n\nProblem: L.\nArray Filling\nSolution: GitHub\nCode\n\n每組 (i, j) 因倍數關係的時候都更新 dp\nvoid solve() {    ifstream fcin(\"input.txt\");    ofstream fcout(\"output.txt\");    int n;    fcin &gt;&gt; n;    vector &lt; int &gt; dp(n+5, 1);    for(int i=2; i&lt;=n+1; i++){        for(int j=2; j*j&lt;=i; j++){            if(i%j==0){                dp[i] += dp[j];                if(j*j!=i){                    dp[i] += dp[i/j];                }            }        }    }    fcout &lt;&lt; dp[n+1] &lt;&lt; endl;}\nContest XX. Greedy\n\nContest\nProblems\n\nC. Gifts\n\nProblem: C.\nGifts\nSolution: GitHub\nCode\n\n\nv 用 pair\n來存，分別存著每個物品的總消耗及票卷用下去時能少多少\nsort(v) 讓總消耗越小的越先取，能讓取的數量最大化\n\nvoid solve() {    int n, b;    cin &gt;&gt; n &gt;&gt; b;    vector &lt; pair &lt; int, int &gt; &gt; v(n);    FOR(i, 0, n){        int p, s;        cin &gt;&gt; p &gt;&gt; s;        v[i].F = p+s;        v[i].S = p/2;    }    sort(ALL(v));    int cnt = 0;    int total = 0;    priority_queue &lt; int &gt; pq;    FOR(i, 0, n){        total += v[i].F;        pq.push(v[i].S);        if(total - pq.top() &lt;= b){            cnt = i + 1;        }else{            break;        }    }    cout &lt;&lt; cnt &lt;&lt; endl;}\nE. Badgers\n\nProblem: E.\nBadgers\nSolution: GitHub\nCode\n\n\n若總共取了 k 個， 則第 i 隻的消耗為\nhi + gi * (k-1)\n最大化數量為 k 個，所以做 for 迴圈去判斷 k\n可以到多少還不會超過 t\n\nvoid solve() {    int n;    cin &gt;&gt; n;    vector &lt; pair &lt; int, int &gt; &gt; v(n);    FOR(i, 0, n) cin &gt;&gt; v[i].F;    FOR(i, 0, n) cin &gt;&gt; v[i].S;    int t;    cin &gt;&gt; t;    int ans = 0;    FOR(k, 1, n+1){        vector &lt; int &gt; costs(n);        FOR(i, 0, n){            costs[i] = v[i].F + v[i].S * (k-1);        }        sort(ALL(costs));        int total = 0;        FOR(i, 0, k){            total += costs[i];        }        if(total &lt;= t){            ans = k;        }else{            break;        }    }    cout &lt;&lt; ans &lt;&lt; endl;}\n","tags":["algorithm","codeforces","competitive-programming"]},{"title":"Codeforces 暑期特訓：我想成為演算法大師 - 團練 GCPC 2017 - Week 5","url":"/blog/2025/08/codeforces-algo-master-week-05-lzr/","content":"2017-2018\nACM-ICPC German Collegiate Programming Contest (GCPC 2017)\n\nContest\nProblems\nNotes\n\nC. Joyride\n\nProblem: C. Joyride\nSolution: GitHub\nCode\n\nvoid solve(){    int x,n,m,t;    cin &gt;&gt; x;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;    vector &lt;vector&lt;int&gt;&gt; path(n+1,vector&lt;int&gt;());    int a,b;    FOR(i,0,m){        cin &gt;&gt; a &gt;&gt; b;        path[a-1].push_back(b-1);        path[b-1].push_back(a-1);    }    vector&lt; pair&lt;int,int&gt; &gt; ride(n);    FOR(i,0,n){        cin &gt;&gt; ride[i].F &gt;&gt; ride[i].S;    }    vector &lt; vector &lt; int &gt; &gt; dp(x+1, vector &lt; int &gt; (n, INT_MAX));    if(ride[0].F &lt;= x){        dp[ride[0].F][0] = ride[0].S;    }    FOR(i, 0, x+1){        FOR(j, 0, n){            if(dp[i][j] == INT_MAX) continue;            for(int k: path[j]){                int nt = i + t + ride[k].F;                if(nt &lt;= x){                    int val = dp[i][j] + ride[k].S;                    dp[nt][k] = min(dp[nt][k], val);                }            }            if(i+ride[j].F&lt;=x){                dp[i+ride[j].F][j] = min(dp[i+ride[j].F][j], dp[i][j]+ride[j].S);            }        }    }    if(dp[x][0]!=INT_MAX){        cout &lt;&lt; dp[x][0] &lt;&lt; endl;    }else{        cout &lt;&lt; \"It is a trap.\" &lt;&lt; endl;    }}\nD. Pants On Fire\n\nProblem: D. Pants On\nFire\nSolution: GitHub\nCode\n\nvoid solve(){    int n, m;    cin &gt;&gt; n &gt;&gt; m;    int siz = 0;    map &lt; string, int &gt; mp;    vector &lt; vector &lt; string &gt; &gt; v;    string a, b, s;    FOR(i, 0, n){        cin &gt;&gt; a;        FOR(j, 0, 3) cin &gt;&gt; s;        cin &gt;&gt; b;        if(mp.find(a)==mp.end()){            mp[a] = siz;            v.PB(vector &lt; string &gt;());            siz++;        }        if(mp.find(b)==mp.end()){            mp[b] = siz;            v.PB(vector &lt; string &gt;());            siz++;        }        v[mp[a]].PB(b);    }    FOR(i, 0, m){        cin &gt;&gt; a;        FOR(j, 0, 3) cin &gt;&gt; s;        cin &gt;&gt; b;        if(mp.find(a)==mp.end() or mp.find(b)==mp.end()){            cout &lt;&lt; \"Pants on Fire\" &lt;&lt; endl;            continue;        }        bool is_fact = false;        queue &lt; string &gt; q;        q.push(a);        while(!q.empty()){            string t = q.front();            q.pop();            if(t == b){                is_fact = true;                break;            }            for(string t2: v[mp[t]]){                q.push(t2);            }        }        if(is_fact){            cout &lt;&lt; \"Fact\" &lt;&lt; endl;        }else{            bool alt_fact = false;            queue &lt; string &gt; q2;            q2.push(b);            while(!q2.empty()){                string t = q2.front();                q2.pop();                if(t == a){                    alt_fact = true;                    break;                }                // cout &lt;&lt; \"v[mp[t]]: \";                // print(v[mp[t]]);                for(string t2: v[mp[t]]){                    q2.push(t2);                }            }            if(alt_fact){                cout &lt;&lt; \"Alternative Fact\" &lt;&lt; endl;            }else{                cout &lt;&lt; \"Pants on Fire\" &lt;&lt; endl;            }        }    }}\nG. Water Testing\n\nProblem: G. Water\nTesting\nSolution: GitHub\nCode\n\nvoid solve(){    int n;    cin &gt;&gt; n;    vector&lt;int&gt; x(n);    vector&lt;int&gt; y(n);    FOR(i, 0, n){        cin &gt;&gt; x[i] &gt;&gt; y[i];    }    int area2 = 0;    int B = 0;    FOR(i, 0, n){        int j = (i+1) % n;        area2 += x[i]*y[j] - x[j]*y[i];        B += std::gcd(abs(x[j]- x[i]), abs(y[j]-y[i]));    }    area2 = abs(area2);    int ans = (area2 - B + 2) / 2;    cout &lt;&lt; ans &lt;&lt; endl;}\nI. Uberwatch\n\nProblem: I. Uberwatch\nSolution: GitHub\nCode\n\nvoid solve(){    int n, m;    cin &gt;&gt; n &gt;&gt; m;    vector&lt;int&gt; x(n);    vector&lt;int&gt; dp(n, 0);    FOR(i, 0, n){        cin &gt;&gt; x[i];    }    FOR(i, m, n){        dp[i] = max(dp[i-1], dp[i-m] + x[i]);    }    cout &lt;&lt; dp[dp.size()-1];}\nK. You Are Fired\n\nProblem: K. You Are\nFired\nSolution: GitHub\nCode\n\nvoid solve(){    int n, d, k;    cin &gt;&gt; n &gt;&gt; d &gt;&gt; k;    vector &lt; pair &lt; int, string &gt; &gt; arr(n);    FOR(i, 0, n){        cin &gt;&gt; arr[i].S &gt;&gt; arr[i].F;    }    sort(ALL(arr), greater());    int m = 0;    int idx = 0;    queue &lt; string &gt; ans;    while(m&lt;d and idx&lt;k){        m += arr[idx].F;        ans.push(arr[idx].S);        idx++;    }    if(m&lt;d){        cout &lt;&lt; \"impossible\" &lt;&lt; endl;    }else{        cout &lt;&lt; idx &lt;&lt; endl;        while(!ans.empty()){            cout &lt;&lt; ans.front() &lt;&lt; \", YOU ARE FIRED!\" &lt;&lt; endl;            ans.pop();        }    }}\n","tags":["algorithm","codeforces","competitive-programming"]},{"title":"Codeforces 暑期特訓：我想成為演算法大師 - Week 5","url":"/blog/2025/07/codeforces-algo-master-week-05/","content":"\nFrom LI2\nContests Group\n\nContest 19. Dynamic\nProgramming\n\nContest\nProblems\n\nC. Turtle and Money\n\nProblem: C.\nTurtle and Money\nSolution: GitHub\nCode\n\n\ndp[i][j] 表示從 (0, 0) 走到\n(i, j) 的加總最大值\ntar = dp[x][y] - arr[x][y] 就可以知道上一個數值，可能為\ndp[x-1][y] 或 dp[x][y-1]\n\nvoid solve() {    int n, m;    cin &gt;&gt; n &gt;&gt; m;    vector &lt; vector &lt; int &gt; &gt; arr(n, vector &lt; int &gt; (m));    FOR(i, 0, n){        FOR(j, 0, m){            cin &gt;&gt; arr[i][j];        }    }    int offs[2][2] = {{-1, 0}, {0, -1}};    vector &lt; vector &lt; int &gt; &gt; dp(n, vector &lt; int &gt; (m, 0));    FOR(i, 0, n){        FOR(j, 0, m){            int val = -INT_MAX;            FOR(k, 0, 2){                int x = i + offs[k][0];                int y = j + offs[k][1];                if(x&gt;=0 and x&lt;n and y&gt;=0 and y&lt;m){                    val = max(val, dp[x][y]);                }            }            if(val == -INT_MAX){                val = 0;            }            val += arr[i][j];            dp[i][j] = val;        }    }    cout &lt;&lt; dp[n-1][m-1] &lt;&lt; endl;    int x = n-1;    int y = m-1;    stack &lt; char &gt; ans;    while(x&gt;0 or y&gt;0){        char dir;        int tar = dp[x][y] - arr[x][y];        if(x-1&gt;=0 and dp[x-1][y]==tar){            dir = 'D';            x--;        }else if(y-1&gt;=0 and dp[x][y-1]==tar){            dir = 'R';            y--;        }        ans.push(dir);    }    while(!ans.empty()){        cout &lt;&lt; ans.top();        ans.pop();    }}\nE. Knight\n\nProblem: E.\nKnight\nSolution: GitHub\nCode\n\n\ndp[i][j] 為走到 (i, j) 的種數\n\nvoid solve() {    int n, m;    cin &gt;&gt; n &gt;&gt; m;    int offs[2][2] = {{-1, -2}, {-2, -1}};    vector &lt; vector &lt; int &gt; &gt; dp(n, vector &lt; int &gt; (m, 0));    dp[0][0] = 1;    FOR(i, 0, n){        FOR(j, 0, m){            FOR(k, 0, 2){                int x = i + offs[k][0];                int y = j + offs[k][1];                if(x&gt;=0 and x&lt;n and y&gt;=0 and y&lt;m){                    dp[i][j] += dp[x][y];                }            }        }    }    cout &lt;&lt; dp[n-1][m-1] &lt;&lt; endl;}\nI. Levenshtein Distance\n\nProblem: I.\nLevenshtein Distance\nSolution: GitHub\nCode\n\n\n兩個字串由後往前找 (i, j) ：\n\n如果 s1[i]==s2[j]: 則可以視 (i+1, j+1)\n為相同的答案\n如果不一樣，那麼就找以下三種作法的最小值+1：\n\nReplace: (i+1, j+1)\nDelete: (i+1, j)\nInsert: (i, j+1)\n\n\n初始化最後一排及最後一列，此狀態問題為字串s1/s2與空字串的差，即為字串s1/s2的長度，因此遞減為0\n可以參考這支影片\n\n\n\nLevenshtein Distance\n\nvoid solve() {    string s1, s2;    cin &gt;&gt; s1 &gt;&gt; s2;    int l1 = s1.size();    int l2 = s2.size();    vector &lt; vector &lt; int &gt; &gt; dp(l1+1, vector &lt; int &gt; (l2+1, 0));    FOR(i, 0, l1+1) dp[i][l2] = l1-i;    FOR(j, 0, l2+1) dp[l1][j] = l2-j;    for(int i=l1-1; i&gt;=0; i--){        for(int j=l2-1; j&gt;=0; j--){            if(s1[i]==s2[j]){                dp[i][j] = dp[i+1][j+1];            }else{                int val = min(dp[i+1][j], dp[i][j+1]);                val = min(val, dp[i+1][j+1]);                dp[i][j] = val + 1;            }        }    }    cout &lt;&lt; dp[0][0] &lt;&lt; endl;}\nN. Knapsack Problem\n\nProblem: N.\nKnapsack Problem\nSolution: GitHub\nCode\n\n\n01 背包問題，只是陣列裡存的是最少物品數量，若為 INT_MAX\n則找不到解法\ndp[i][j] 表示前 i 個物品當中，重量剛好為\nj 的最少物品數量\n\nvoid solve() {    ifstream fcin(\"input.txt\");    ofstream fcout(\"output.txt\");    int n, m;    fcin &gt;&gt; n &gt;&gt; m;    vector &lt; int &gt; arr(n);    FOR(i, 0, n) fcin &gt;&gt; arr[i];    vector &lt; vector &lt; int &gt; &gt; dp(n+1, vector &lt; int &gt; (m+1, INT_MAX));    FOR(i, 0, n+1) dp[i][0] = 0;    FOR(i, 1, n+1){        FOR(j, 1, m+1){            dp[i][j] = dp[i-1][j];            if(j-arr[i-1]&gt;=0 and dp[i-1][j-arr[i-1]]!=INT_MAX){                dp[i][j] = min(dp[i][j], dp[i-1][j-arr[i-1]]+1);            }        }    }    if(dp[n][m]!=INT_MAX){        fcout &lt;&lt; dp[n][m] &lt;&lt; endl;    }else{        fcout &lt;&lt; 0 &lt;&lt; endl;    }}\nP. Weights\n\nProblem: P.\nWeights\nSolution: GitHub\nCode\n\n\n要能將重量平均放在兩邊，則每邊重量各別為總重量的一半\n若總重量的一半為 m ，則可用 01 背包問題求背包最大為\nm 時，是否能裝滿\n\nvoid solve() {    ifstream fcin(\"input.txt\");    ofstream fcout(\"output.txt\");    int n;    fcin &gt;&gt; n;    int m = 0;    vector &lt; int &gt; arr(n);    FOR(i, 0, n){        fcin &gt;&gt; arr[i];        m += arr[i];    }    if(m%2==1){        fcout &lt;&lt; \"NO\" &lt;&lt; endl;        return;    }    m /= 2;    vector &lt; vector &lt; int &gt; &gt; dp(n+1, vector &lt; int &gt; (m+1, 0));    FOR(i, 0, n+1) dp[i][m] = 0;    FOR(j, 0, m+1){        if(j&gt;=arr[0]) dp[0][j] = arr[0];        else dp[0][j] = 0;    }    FOR(i, 1, n){        FOR(j, 1, m+1){            dp[i][j] = dp[i-1][j];            if(j-arr[i-1]&gt;=0){                dp[i][j] = max(dp[i][j], dp[i-1][j-arr[i-1]]+arr[i-1]);            }        }    }    if(dp[n-1][m] == m){        fcout &lt;&lt; \"YES\" &lt;&lt; endl;    }else{        fcout &lt;&lt; \"NO\" &lt;&lt; endl;    }}\n","tags":["algorithm","codeforces","competitive-programming"]},{"title":"Codeforces 暑期特訓：我想成為演算法大師 - 團練 FJNU Programming Contest 2024 - Week 6","url":"/blog/2025/08/codeforces-algo-master-week-06-lzr/","content":"2024 Fujian Normal\nUniversity Programming Contest\n\nContest\nProblems\nNotes\n\nA. Crazy Yesterday\n\nProblem: A. Crazy\nYesterday\nSolution: GitHub\nCode\n\nvoid solve(){    int n;    cin &gt;&gt; n;    int in;    while(n--){        cin &gt;&gt; in;        if(in == 1) in += 7;        cout &lt;&lt; in-1 &lt;&lt; endl;    }}\nC. Chain Reaction\n\nProblem: C. Chain\nReaction\nSolution: GitHub\nCode\n\nvoid solve(){    int n,m;    cin &gt;&gt; n &gt;&gt; m;    int a,b;    FOR(i,0,m) cin &gt;&gt; a &gt;&gt; b;    cout &lt;&lt; n &lt;&lt; \" \";    FOR(i,0,n) cout &lt;&lt; i+1 &lt;&lt; \" \";    cout &lt;&lt; endl;}\nD. XOR Pairing\n\nProblem: D. XOR\nPairing\nSolution: GitHub\nCode\n\nvoid solve(){    int n, k;    cin &gt;&gt; n &gt;&gt; k;    map &lt; int, int &gt; mp;    FOR(i, 0, n){        int a;        cin &gt;&gt; a;        mp[a]++;    }    int ans = 0;    set&lt;int&gt; visited;    for(auto &amp;[x, cx] : mp){        int tar = k ^ x;        if(mp.find(tar) == mp.end()){            continue;        }        if(tar == x){            ans += cx * (cx -1 ) / 2;        }else if(!visited.count(tar)){            ans += cx * mp[tar];        }        visited.insert(x);    }    cout &lt;&lt; ans &lt;&lt; endl;}\nF. Double Holding\n\nProblem: F. Double\nHolding\nSolution: GitHub\nCode\n\nbool cpm(pair&lt;int,int&gt; a,pair&lt;int,int&gt; b){    return a.F &lt; b.F;}void solve(){    int n,m,E;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; E;    vector &lt; pair&lt;int,int&gt; &gt; up;    vector &lt; pair&lt;int,int&gt; &gt; down;    int start,end;    FOR(i,0,n){        cin &gt;&gt; start &gt;&gt; end;        up.PB({start,end});    }    sort(ALL(up),cpm);    FOR(i,0,m){        cin &gt;&gt; start &gt;&gt; end;        down.PB({start,end});    }    sort(ALL(down),cpm);    // for(auto i:up) cout &lt;&lt; i.F &lt;&lt; \" \" &lt;&lt; i.S &lt;&lt; endl;    // cout &lt;&lt; endl;    // for(auto i:down) cout &lt;&lt; i.F &lt;&lt; \" \" &lt;&lt; i.S &lt;&lt; endl;    int i=0,j=0;    // cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; \" \" &lt;&lt; E &lt;&lt; endl;    while(i&lt;n and j&lt;m and E &gt;= 0){        // cout &lt;&lt; \"123\" &lt;&lt; endl;        if(up[i].S &lt;= down[j].F){            // cout &lt;&lt; 1 &lt;&lt; endl;            i += 1;        }        else if(up[i].F &gt;= down[j].S){            // cout &lt;&lt; 2 &lt;&lt; endl;            j += 1;        }        else if(up[i].S &gt; down[j].F and up[i].S &lt;= down[j].S and up[i].F &lt;= down[j].F){            // cout &lt;&lt; E &lt;&lt; \" \" &lt;&lt; (down[j].F-up[i].S) &lt;&lt; endl;            E += (down[j].F-up[i].S);            i += 1;        }        else if(up[i].S &gt; down[j].F and up[i].S &lt;= down[j].S and up[i].F &gt;  down[j].F){            // cout &lt;&lt; E &lt;&lt; \" \" &lt;&lt; (up[i].F-up[i].S) &lt;&lt; endl;            E += (up[i].F-up[i].S);            i += 1;        }        else if(up[i].S &gt; down[j].F and up[i].S &gt;  down[j].S and up[i].F &lt;= down[j].F){            // cout &lt;&lt; E &lt;&lt; \" \" &lt;&lt; (down[j].F-down[j].S) &lt;&lt; endl;            E += (down[j].F-down[j].S);            j += 1;        }        else if(up[i].S &gt; down[j].F and up[i].S &gt;  down[j].S and up[i].F &lt;= down[j].S){            // cout &lt;&lt; E &lt;&lt; \" \" &lt;&lt; (up[i].F-down[j].S) &lt;&lt; endl;            E += (up[i].F-down[j].S);            j += 1;        }        // else cout &lt;&lt; up[i].F &lt;&lt; \" \" &lt;&lt; up[i].S &lt;&lt; \" \" &lt;&lt; down[j].F &lt;&lt; \" \" &lt;&lt; down[j].S &lt;&lt; endl;    }    if(E &gt;= 0) cout &lt;&lt; E &lt;&lt; endl;    else cout &lt;&lt; -1 &lt;&lt; endl;}\nG. Color Contagion\n\nProblem: G. Color\nContagion\nSolution: GitHub\nCode\n\nconst int MAXN = 2e5 + 5;int fact[MAXN], invfact[MAXN];void calculateFactorial(int n){    fact[0] = 1;    for(int i = 1; i &lt;= n; i++){        fact[i] = (fact[i-1] * i) % MOD;    }    invfact[n] = POW(fact[n], MOD-2);    for(int i = n-1; i &gt;= 0; i--){        invfact[i] = (invfact[i+1] * (i+1)) % MOD;    }}vector&lt;int&gt; G[MAXN];int sz[MAXN];int dp[MAXN];void dfs(int u, int p){    sz[u] = 1;    dp[u] = 1;    for(auto nxt: G[u]){        if(nxt == p){            continue;        }        dfs(nxt, u);        sz[u] += sz[nxt];        dp[u] = (dp[u] * dp[nxt]) % MOD;        dp[u] = (dp[u] * invfact[sz[nxt]]) % MOD;    }    dp[u] = (dp[u] * fact[sz[u] - 1]) % MOD;}void solve(){    int n;    cin &gt;&gt; n;    for(int i = 1; i &lt;= n; i++){        G[i].clear();        sz[i] = 0;        dp[i] = 0;    }    for(int i = 1; i &lt;= n-1; i++){        int u, v;        cin &gt;&gt; u &gt;&gt; v;        G[u].PB(v);        G[v].PB(u);    }    dfs(1, -1);    cout &lt;&lt; dp[1] &lt;&lt; endl;}signed main(){    ios::sync_with_stdio(false),cin.tie(0);    calculateFactorial(MAXN - 1);    int t;    cin &gt;&gt; t;    while(t--) solve();    return 0;}\nJ. Shifting Tournament\n\nProblem: J. Shifting\nTournament\nSolution: GitHub\nCode\n\nvoid solve(){    int k;    cin &gt;&gt; k;    string s;    cin &gt;&gt; s;    vector &lt; int &gt; dp(k+1);    dp[0] = 1;    FOR(i, 1, k+1){        dp[i] = dp[i-1] * 2;        dp[i] %= 998244353;    }    // print(dp);    int t = 0;    FOR(i, 0, k){        if(s[i]=='?') t++;    }    // cout &lt;&lt; t &lt;&lt; endl;    int q;    cin &gt;&gt; q;    int p;    char c;    while(q--){        cin &gt;&gt; p &gt;&gt; c;        p--;        if(s[p]=='?' and c!='?') t--;        else if(s[p]!='?' and c=='?') t++;        s[p] = c;        cout &lt;&lt; dp[t] &lt;&lt; endl;    }}\nL. Terabyte Connection\n\nProblem: L. Terabyte\nConnection\nSolution: GitHub\nCode\n\nvoid solve(){    int n;    cin &gt;&gt; n;    int ans_p = 0;    int ans_t = 0;    int p, t;    FOR(i, 0, n){        cin &gt;&gt; p &gt;&gt; t;        ans_p = max(ans_p, p);        ans_t = max(ans_t, p+t);    }    cout &lt;&lt; ans_p &lt;&lt; ' ' &lt;&lt; ans_t &lt;&lt; endl;}\n","tags":["algorithm","codeforces","competitive-programming"]},{"title":"Codeforces 暑期特訓：我想成為演算法大師 - Week 6","url":"/blog/2025/08/codeforces-algo-master-week-06/","content":"\nFrom LI2\nContests Group\n\nContest 18. Graphs, DFS, BFS\n\nContest\nProblems\n\nC. Looking for cycle\n\nProblem: C.\nLooking for cycle\nSolution: GitHub\nCode\n\n\nvisit 陣列中， 0\n表示沒進去過，1 表示是當前的迴圈，2\n表示之前已經走過發現沒有 cycle\n若 visit 僅為 bool ，會讓沒有 cycle\n的路徑重複走很多遍\n1 → 2 → 3 → 4 → 2 這樣的 cycle 是\n2 3 4\n用 parent 陣列存 dfs 走的路徑\n\nvoid solve() {    int n, m;    cin &gt;&gt; n &gt;&gt; m;    vector &lt; vector &lt; int &gt; &gt; G(n);    int v, u;    FOR(i, 0, m){        cin &gt;&gt; v &gt;&gt; u;        G[v-1].PB(u);    }    bool ans = false;    int start = -1;    int end = -1;    vector &lt; int &gt; visit(n, 0);    vector &lt; int &gt; parent(n, -1);    auto dfs = [&amp;](auto&amp;&amp; self, int x) -&gt; bool {        visit[x-1] = 1;        for(int y: G[x-1]){            if(visit[y-1]==1){                start = y;                end = x;                return true;            }            if(visit[y-1]==0){                parent[y-1] = x;                if(self(self, y)){                    return true;                }            }        }        visit[x-1] = 2;        return false;    };    FOR(i, 1, n+1){        if(visit[i-1]==0){            if(dfs(dfs, i)){                ans = true;                break;            }        }    }    if(ans){        cout &lt;&lt; \"YES\" &lt;&lt; endl;        int x = end;        vector &lt; int &gt; cycle;        while(x!=start){            cycle.PB(x);            x = parent[x-1];        }        cycle.PB(x);        reverse(ALL(cycle));        print(cycle);    }else{        cout &lt;&lt; \"NO\" &lt;&lt; endl;    }}\nE. Bipartite graph\n\nProblem: E.\nBipartite graph\nSolution: GitHub\nCode\n\n\n用 bfs 對每個點去跑，如果還沒走過就先設 1，接下來每層再反轉 1 或\n2\n\nvoid solve() {    int n, m;    cin &gt;&gt; n &gt;&gt; m;    int u, v;    vector &lt; vector &lt; int &gt; &gt; G(n+1);    FOR(i, 0, m){        cin &gt;&gt; u &gt;&gt; v;        G[u].PB(v);        G[v].PB(u);    }    bool ans = true;    vector &lt; int &gt; color(n+1, 0);    FOR(i, 1, n+1){        if(color[i]!=0) continue;        queue &lt; int &gt; q;        color[i] = 1;        q.push(i);        while(!q.empty()){            int t = q.front();            q.pop();            for(int y: G[t]){                if(color[y]==0){                    color[y] = 3 - color[t];                    q.push(y);                }else if(color[y]==color[t]){                    ans = false;                    break;                }            }            if(!ans) break;        }        if(!ans) break;    }    if(ans){        cout &lt;&lt; \"YES\" &lt;&lt; endl;        FOR(i, 1, n+1){            cout &lt;&lt; color[i] &lt;&lt; ' ';        }    }else{        cout &lt;&lt; \"NO\" &lt;&lt; endl;    }}\nJ. Mafija\n\nProblem: J.\nMafija\nSolution: GitHub\nCode\n\n\n如果 A → B 且 A 是暴徒，則\nB 一定是平民\n如果 A → B 且 B 是暴徒，則\nA 一定是平民\nTC3 是錯的\n\nvoid solve() {    int n;    cin &gt;&gt; n;    vector &lt; int &gt; G(n+1);    FOR(i, 1, n+1){        cin &gt;&gt; G[i];    }    vector &lt; int &gt; state(n+1, 0);    vector &lt; bool &gt; mobster(n+1, false);    int ans = 0;    auto dfs = [&amp;](auto&amp;&amp; self, int u) -&gt; void {        state[u] = 1;        int v = G[u];        if(state[v]==0){            self(self, v);        }        else if(state[v]==1){            ans++;            while(true){                state[v] = 2;                mobster[v] = false;                if(v==u) break;                v = G[v];            }            return;        }        if(state[u]==2) return;        if(mobster[v]){            mobster[u] = false;        }else{            mobster[u] = true;            ans++;        }        state[u] = 2;    };    FOR(i, 1, n+1){        if(state[i]==0) dfs(dfs, i);    }    cout &lt;&lt; ans &lt;&lt; endl;}\nContest 20. DSU\n\nContest\nProblems\n\nA. Islands\n\nProblem: A.\nIslands\nSolution: GitHub\nCode\n\n\n題目要求的是前幾座橋蓋完之後所有點都能相通\n用 pieces 來存共有幾個不相連的區塊，當\npieces==1 的時候就不用再繼續蓋了\n\nvoid solve() {    int n, m;    cin &gt;&gt; n &gt;&gt; m;    vector &lt; int &gt; boss(n);    FOR(i, 0, n) boss[i] = i;    int pieces = n;    auto find_root = [&amp;](auto&amp;&amp; self, int x) -&gt; int {        if(boss[x]==x) return x;        int root = self(self, boss[x]);        boss[x] = root;        return root;    };    auto connect = [&amp;](int x, int y) -&gt; void {        int root_x = find_root(find_root, x);        int root_y = find_root(find_root, y);        if(root_x != root_y){            boss[root_x] = boss[root_y];            pieces--;        }    };    int ans = m;    int u, v;    FOR(i, 0, m){        cin &gt;&gt; u &gt;&gt; v;        u--;        v--;        connect(u, v);        if(pieces==1){            ans = i+1;            break;        }    }    cout &lt;&lt; ans &lt;&lt; endl;}\nF. Vessels\n\nProblem: F.\nVessels\nSolution: GitHub\nCode\n\n\narr 存 n 個容器的容量，brr 存\nn 個容器了多少的水\n若第 i 個容器裝滿，那麼水會流進第 i+1\n個容器裡，還是滿的話就再繼續往下找，所以這裡用 DSU 優化，\nboss 存還沒滿的那個容器 idx\n如果流到了 idx 為 n\n時，代表流到了地上，就跳出迴圈不用管\n\nvoid solve() {    int n;    cin &gt;&gt; n;    vector &lt; int &gt; arr(n);    FOR(i, 0, n) cin &gt;&gt; arr[i];    vector &lt; int &gt; brr(n, 0);    vector &lt; int &gt; boss(n+1);    FOR(i, 0, n+1) boss[i] = i;    auto find_root = [&amp;](auto&amp;&amp; self, int x) -&gt; int {        if(boss[x]==x) return x;        int root = self(self, boss[x]);        boss[x] = root;        return root;    };    int m;    cin &gt;&gt; m;    int q, p, x, k;    FOR(i, 0, m){        cin &gt;&gt; q;        if(q==1){            cin &gt;&gt; p &gt;&gt; x;            p--;            while(x&gt;0){                p = find_root(find_root, p);                if(p&gt;=n) break;                int avil = arr[p]-brr[p];                if(avil&gt;=x){                    brr[p] += x;                    x = 0;                }else{                    x -= avil;                    brr[p] = arr[p];                    boss[p] = find_root(find_root, p+1);                }            }        }else if(q==2){            cin &gt;&gt; k;            cout &lt;&lt; brr[k-1] &lt;&lt; endl;        }    }}\nContest 22. Shortest Paths\n\nContest\nProblems\n\nC. Rain 2\n\nProblem: C.\nRain 2\nSolution: GitHub Code\n\nD. Roadblock\n\nProblem: D.\nRoadblock\nSolution: GitHub Code\n\n","tags":["algorithm","codeforces","competitive-programming"]},{"title":"Docker - Ubuntu SSH Setup","url":"/blog/2024/11/docker-ubuntu-ssh-setup/","content":"Docker - Ubuntu SSH Setup\nHost: Use the same port -&gt; just change to the SSH\nport that does not conflict with NAS.\nEnvironment Settings\nfor Ubuntu Container\nDockerfile\nFROM ubuntu:latestRUN apt-get update &amp;&amp; apt-get install -y openssh-serverRUN mkdir /var/run/sshdRUN echo 'root:your_password' | chpasswdRUN sed -i 's/PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_configRUN sed 's@session\\s*required\\s*pam_loginuid.so@session optional pam_loginuid.so@g' -i /etc/pam.d/sshd# Other installationsRUN apt-get upgrade -yRUN apt-get install -y sudo nano vim curl gitEXPOSE 22CMD [\"/usr/sbin/sshd\", \"-D\"]\nDocker Build and Push to\nDocker Hub\ndocker build -t ubuntu_ssh .docker tag ubuntu_ssh wulukewu/ubuntu_ssh:latestdocker push wulukewu/ubuntu_ssh:latest\nInstall OpenSSH-Server\napt-get update apt-get install -y openssh-servermkdir /var/run/sshdecho 'root:your_password' | chpasswdsed -i 's/PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_configsed 's@session\\s*required\\s*pam_loginuid.so@session optional pam_loginuid.so@g' -i /etc/pam.d/sshd/usr/sbin/sshd -D\n\nPull and Run the ubuntu_ssh\nImage\nPull ubuntu_ssh from Docker\nHub\nsudo docker pull wulukewu/ubuntu_ssh:latest\nRun ubuntu_ssh in Host\nsudo docker run -d --net=host --name ubuntu_ssh wulukewu/ubuntu_ssh:latest\nAccess the Ubuntu Container\nsudo docker exec -i -t ubuntu_ssh /bin/bash\n\nHostname Configuration\nChange Hostname\nsudo nano /etc/hostnamesudo nano /etc/hostssudo reboot\nDisplay the Current Hostname\nhostname\n\nSSH Configuration\nChange SSH Port\nsudo nano /etc/ssh/sshd_configservice ssh restart\n\nUser Management\nAdd a New Sudo User\nadduser user_name\nAdd the User to the Sudo\nGroup\nusermod -aG sudo user_nameusermod -aG root user_name\nChange User Password\nsudo passwd user_name\nTest Sudo Access\nsu - user_name\n\nReferences\n\nHow\nto SSH into a Docker Container | Step-by-Step Tutorial\nSave\nDocker Image as a File\nUbuntu\nLinux Change Hostname\nDay 21:\nIntroduction to Docker Networking (Part 2)\nDocker\nBasic Commands Cheat Sheet\nHow\nto Create a New Sudo-Enabled User on Ubuntu\nChange\nPassword for Root and User Accounts\nAsk\nChatGPT\n\n","tags":["docker","ubuntu","ssh","devops","containerization","linux","tutorial"]},{"title":"設定GitHub SSH金鑰","url":"/blog/2024/11/github-ssh-key/","content":"Setup\n\n根據email創建一個新的SSH金鑰\nssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"\n開啟ssh-agent，將私鑰加入到ssh-agent\neval \"$(ssh-agent -s)\"ssh-add -K ~/.ssh/id_rsa\n上傳公鑰，並到GitHub上上傳SSH key\ncat ~/.ssh/id_rsa.pub GitHub Keys Settings \nssh連接GitHub SSH ssh -T git@github.com\n\nResources\n\n設定 Github\nSSH 金鑰 feat. Github SSH、HTTPS 的差異\nHow to clone, push, and pull\nwith git (beginners GitHub tutorial)\n\n","tags":["ssh","tutorial","github","git","setup"]},{"title":"量子計算基礎 - 從單量子位到多量子位系統","url":"/blog/2025/04/quantum-system/","content":"大一下去修了一門量子計算的課，前面的概念跟線性代數有滿多相似的地方，後半部分才真正開始講量子演算法。\n量子計算基礎簡介\n量子電腦與傳統電腦的差別，在於傳統電腦儲存資訊的最小單位是位元（bit），量子電腦則是使用量子位元（qubit）。位元可以存在一種狀態，1\n或是 0。量子位元特別的地方是，它在一個時間，可以同時是 1 也是 0。\n\n\nbit vs qubit\n\n量子在通訊上有很高的安全性，利用量子力學原理，能夠在兩方之間安全地分發加密密鑰。任何試圖竊聽的行為都會擾亂量子態，被接收方檢測到。\n\n\nquantum application\n\n過去超大整數的質因數分解，即使傳統超級電腦的運算能力也無法在短時間破解。不過，量子演算法（Shor’s\nAlgorithm，可解質因數分解）能在合理時間內完成破解，會顛覆現在 RSA\n等加密算法。\nClassical v.s. Quantum\n拆解質數\n現在有個數字 N = f1 × f2，由\nf1, f2\n兩個很大的質數構成。破解 RSA 的核心，就是從 N 找出 f1 和 f2。\n想要找到 N\n的因數，只要不斷給定 g，透過\nEuclid’s Algorithm（歐幾里得演算法，又稱輾轉相除法）快速計算判斷，當\ng 使得公因數 gcd (N,g) = a &gt; 1\n時，對於 RSA 來說就已經結束了。\n但要找到 g\n可以滿足上述條件其實並不容易，事實上真的只能一個一個猜 g\n是多少。不過，我們可以將這個隨機猜測的數字 g 轉換成很有可能滿足條件的 gp/2 ± 1。\n\n\n為什麼是 gp/2 ± 1 ？\n\n若給定兩個數 A, B，且 gcd (A,B) = 1，則存在一個正整數\np 使得 Ap = m ⋅ B + 1，其中\nm\n為某個整數（根據歐拉定理）。\n舉兩個例子來說：\nEx1\n給定 (A,B) = (7,15)，則：\n\nEx2\n給定 (A,B) = (42,13)，則：\n\n因此，m ⋅ B = Ap − 1 = (Ap/2+1)(Ap/2−1)\n\n將機會不大的數字 g 轉換成很有可能的gp/2 ± 1，只要找到這樣的p就好（p要是偶數才能真正拆解喔！）\nClassical\n我們用個例子來想，要用傳統電腦找到一個 p 使得 42p = m × 13 + 1，可能會從\np = 1, 2, 3, …\n開始一個一個慢慢代入判斷，但如果現在給定 gp = m × N + 1\n的 g 和 N 都很大呢？\n對傳統電腦來說，就真的只能一個一個數字慢慢算，直到找到答案為止，這也就是為什麼現在能夠這麼廣泛地使用\nRSA 加密。但是對量子電腦來說就不太一樣了……\nQuantum\n用量子來計算的好處是因為有疊加態（superposition）。\n我們可以構建一個 f(x) 的函數。若要計算 a, b, c, d\n各自的函數值，對於傳統電腦來說，就是一個一個代入計算：\nf(a),  f(b),  f(c),  f(d)\n但在量子的世界，可以讓一個或多個量子位元處於疊加態：\n|a⟩+|b⟩ + |c⟩+|d⟩\n然後將這個疊加態輸入設計好的 f(x)\n邏輯閘做平行運算，得到：\n|f(a)⟩+|f(b)⟩ + |f(c)⟩+|f(d)⟩\n\n到這邊還需要先知道另一個 Shor’s Algorithm\n的核心概念。一樣目標是找到滿足條件的 p。如果現在隨便找的一個 x，會得到 gx = mN + r，其中\nr 是餘數，那麼很容易證明 gx + p = m2N + r\n也成立。\n換句話說，對於某個週期 p，gx 模 N 的餘數會重複出現：\ngx mod  N = r ⟹ gx + p mod  N = r\n這個「週期性」就是 Shor’s Algorithm\n能有效率分解質因數的關鍵。只要能找到這個週期 p，就能透過 Quantum Fourier\nTransform（量子傅立葉變換）進一步拆解 N。\n\n\nquantum fourier transform\n\n\n前面提到，在量子的世界中，我們可以構建量子閘，讓所有輸入 x 的餘數 r 同時被計算出來：\n|x⟩→|x⟩|gx mod  N⟩\n這表示，當量子位元處於疊加態時，經過適當設計的量子閘後，所有 x 對應的 gx mod  N\n都會同時存在於量子態中。\n\n\nquantum shor process\n\n從這些餘數當中，任取一個 r，可以經由適當的轉換，將其餘的\nx 都變成 0。最後透過 Fourier Transform 找出的 g = x 和 p，就可以利用前面提過的傳統方式，判斷\ngp/2 ± 1\n是否與 N 有公因數，將 N 拆解開來。\n\n\n標準的 2048 位元 RSA\n加密，就算用目前世界上最強的超級電腦（太湖之光，中國製），花費地球年齡的時間（46\n億年）都無法破解。\n\n如果量子電腦真的存在，能將運算時間由數十億年縮減為幾分、幾秒鐘，數字\nN 都能快速被拆解成 f1, f2\n兩個質數，現在的金融、通訊等都會受到嚴重的影響。但是現在還不需要擔心，因為目前的技術還沒辦法處理太多位元的數字，可能只能拆解\n15 = 3 × 5 這種容易的而已。\n\n單量子位系統\n(Single-Qubit Quantum Systems)\n在量子計算中，量子位元 (Qubit)\n是最基本的資訊單位，類似於傳統計算中的位元\n(Bit)。然而，與傳統位元只能處於 0 或 1 的狀態不同，量子位元可以同時處於\n0 和 1 的疊加態。先來介紹一下量子計算所處於的空間定義：\nHilbert 空間 (Hilbert Space)\n對於單量子位元系統，Hilbert 空間是一個複數 ℂ 中的 inner product\nspace，有向量加法、純量乘法，以及計算向量之間的內積。\n\nIf |ψ⟩,|ϕ⟩ ∈ V, α, β ∈ ℂ, then α|ψ⟩+β|ϕ⟩ ∈ V.\n\n在單量子位元系統當中，我們常用, 當作標準基底，而一個量子位元則可表示為 |ψ⟩=α|0⟩ + β|1⟩。\n至於維度 (Dimension) 為 N\n的向量空間，則會以 {|e1⟩,|e2⟩, …, |eN⟩}\n當作標準基底，也可以寫成{|0⟩,|1⟩, …, |N − 1⟩} 。\n\n\n正規化 (Normalized)：⟨e1|e1⟩=⟨e2|e2⟩ = … = ⟨eN|eN⟩ = 1\n正交 (Orthogoral)：⟨e1|e2⟩=⟨e2|e3⟩ = … = ⟨eN − 1|eN⟩ = 0\n\n因此：\n\nNote：單量子位元系統的 Hilbert 空間是一個 N = 2\n的簡單空間，而複數量子位元系統的 Hilbert\n空間維度會隨著量子位元數量增加而指數成長，例如 n = 5 個量子位元系統的 Hilbert\n空間維度為 N = 25 = 32。\n範例\n我們拿一個例子來說明好了，假設 , ，那麼可以做下列這幾個運算：\n對偶向量 (Dual Vector)\n\n\n\n\n內積 (Inner Product)\n\n\n\n\n因此：\n\n⟨v|v⟩ ∈ ℝ ≥ 0\n(non-negative real)\n\n(a⟨v2|+b⟨v3|)|v1⟩=a⟨v2|v1⟩ + b⟨v3|v1⟩\n\n向量範數 (Norm)\n\n正規化向量 (Normalized\nVector)\n量子態必須是正規化的，以保證測量結果的機率總和為 1。\n\n例如：\n\n計算內積：\n\n\n投影運算子 (Projection\nOperator)\n\n\n\n此時算出的  和  就分別是 |ψ⟩ 在 |e1⟩ 和 |e2⟩\n兩個基底的投影運算子。\n崩塌 (Collapse)\n我們前面說過，|ψ⟩=∑iαi|ei⟩\n是由N維的基底所組成的。其中\n|ei⟩ 在\n|ψ⟩ 出現的機率為 |αi|2，則|α1|2 + |α2|2 + … + |αN|2 = 1。\n在 |ψ⟩=∑iαi|ei⟩\n當中，|ei⟩\n出現的機率取決於 |αi|2，而此時的觀測是不可逆的。當測量完成後，量子態會崩塌到對應的基底態\n|ei⟩，並且無法回復到原本的疊加態。因此測量過程不可逆，且量子態的疊加性在測量後不復存在。\n\n\nQuantum Measurement Single\n\n範例\n\n\n|e1⟩ 在\n|ψ⟩ 出現的機率為 \n|e2⟩ 在\n|ψ⟩ 出現的機率為 \n\n\n量子態 (Quantum State)：\nPi|ψ⟩→|ei⟩\n|ψ⟩=α1|e1⟩ + α2|e2⟩\n經典態 (Classical State)：\n\n\n量子態在測量後會崩塌到某個基底態，而此時的經典態不再具有量子態的疊加性。\nBloch 球 (Bloch Sphere)\nBloch 球用於表示單量子位的狀態：video\n\n\nBloch Sphere\n\n\n\n|0⟩ → (0,0,1)\n|1⟩ → (0,0,−1)\n| + ⟩ → (1,0,0)\n| − ⟩ → (−1,0,0)\n|i⟩ → (0,1,0)\n| − i⟩ → (0,−1,0)\n\nBloch 球上的 I, X, Y, Z\n運算子幾何意義\n\nI (單位運算子)：不改變 Bloch\n球上的狀態（即不旋轉）。\nX 門（Pauli-X）：繞 x 軸旋轉 π 弧度（180°），將 |0⟩ 和 |1⟩\n互換。對應於 Bloch 球上的 x\n軸翻轉。\nY 門（Pauli-Y）：繞 y 軸旋轉 π 弧度（180°），將 |0⟩ 和 |1⟩\n互換，並帶有相位。對應於 Bloch 球上的 y 軸翻轉。\nZ 門（Pauli-Z）：繞 z 軸旋轉 π 弧度（180°），將 | + ⟩ 和 | − ⟩ 互換，|0⟩ 不變，|1⟩ 變號。對應於 Bloch 球上的 z 軸翻轉。\n\n簡單來說，X, Y, Z 分別對應於 Bloch 球上繞 x、y、z 軸的 180° 旋轉。\n\n多量子位系統\n(Multiple-Qubit Systems)\nHilbert 空間與張量積\n(Tensor Product)\n多量子位系統的 Hilbert 空間是單量子位空間的張量積：\nH2 ⊗ H2 ⊗ … ⊗ H2 = HN  (N\n個)\n假設：\n\n第 0 個 H2：{|0⟩0,|1⟩0}\n第 1 個 H2：{|0⟩1,|1⟩1}\n\nTensor Product\nH2 ⊗ H2:\n|ψ1⟩⊗|ψ0⟩ = [α1|0⟩1+β1|1⟩1] ⊗ [α0|0⟩0+β0|1⟩0]\n = α1α0|0⟩1⊗|0⟩0 + α1β0|0⟩1⊗|1⟩0 + β1α0|1⟩1⊗|0⟩0 + β1β0|1⟩1⊗|1⟩0\n = α1α0|00⟩10+α1β0|01⟩10 + β1α0|10⟩10+β1β0|11⟩10\n而此時：\n\n|0⟩1⊗|0⟩0 = |00⟩10\n|0⟩1⊗|1⟩0 = |01⟩10\n|1⟩1⊗|0⟩0 = |10⟩10\n|1⟩1⊗|1⟩0 = |11⟩10\n\n|00⟩,|01⟩, |10⟩,|11⟩ 為 H4 的基底\n範例\n假設：\n\n第 0 個 H2：, , T0 operator\n第 1 個 H2：, , T1 operator\n\n計算張量積：\n\n\n\n\n運算子與單元矩陣\n在多量子位系統中，運算子 T\n和單位運算子 I\n的結合可以用來描述量子態的演化。假設 T0 和 T1\n是作用於不同量子位的運算子，若它們相等，即 T0 = T1 = T，則可以簡化為單一運算子\nT 的作用。\n單位運算子 I\n的作用不會改變量子態，滿足以下關係：\nI|ψ⟩=|ψ⟩\n其中，單位運算子 I\n的矩陣形式為：\n\n當運算子 T\n作用於單一量子位的量子態時，可以表示為：\nT|ψ1⟩,|ψ0⟩\n而當運算子 T 與單位運算子\nI\n結合，作用於多量子位系統的張量積態時，則可以表示為：\n(T⊗I)(|ψ1⟩⊗|ψ0⟩)\n單位運算子：\n\n單元矩陣 (Unitary Matrix)\n假設 U ：\n\n則可發現 U−1 = U†\nNote：共軛轉置 (conjugate) U† = (U*)T\n\n\n\nU 是 Unitary Matrix\n\n量子門與狀態轉換\n(Quantum Gates and State Transformations)\n常見量子門\nH2\n的基本運算子為 I, X, Y, Z\n基本運算子 - X (NOT)\nX|0⟩=|1⟩,  X|1⟩=|0⟩\n\n其中：\nX2 = I = X−1X\nX−1 = X\n基本運算子 - Y\nY|0⟩=+i|1⟩,  Y|1⟩=−i|0⟩\n\n其中：\nY† = Y\n\nY2 = I\nY 是單元矩陣\n基本運算子 - Z\nZ|0⟩=|0⟩,  Z|1⟩=−|1⟩\n\n糾纏態與測量\n在H2中，\nU = αI + βX + γY + δZ\nBell State （貝爾態）\n\n\n\n\nBell State 是兩個 qubit 之間最純粹的糾纏態。\n假設：\n|ψ1⟩=α1|0⟩ + β1|1⟩,  |ψ0⟩ = α0|0⟩+β0|1⟩\n則它們的張量積\n|ψ1⟩⊗|ψ0⟩ = α1α0|00⟩+α1β0|01⟩ + β1α0|10⟩+β1β0|11⟩\n如果 β1α0 = α1β0 = 0，則為\n可分離態；否則為 糾纏態\n(entanglement)。\n糾纏測量\nα1α0|00⟩+β1β0|11⟩ ≠ |ψ1⟩⊗|ψ0⟩\n例如：\n|00⟩+|11⟩ = |0⟩1⊗|0⟩0 + |1⟩1⊗|1⟩0\n\n\nEntangled Measurement\n\n此時去做量子測量：\n\n第 1 個質點測量到 |0⟩，則第 0\n個質點就確定為 |0⟩\n第 1 個質點測量到 |1⟩，則第 0\n個質點就確定為 |1⟩\n\n\n\nQuantum Measurement Multiple\n\n逆向計算 (Reverse\nComputation)\nCNOT (Control NOT)\nCNOT 門的運作如下：\n\n\nCNOT Gate\n\n\nCNOT 性質：\nCNOT ⋅ CNOT = I\nCNOT−1 ⋅ CNOT = I\nCNOT−1 = CNOT\n舉個例子：\n\n\n\n\n\n\n\n1 ⊗ 0 = 1\n1 ⊗ 1 = 0\n\n\n\n\n\n\n\n\n\n這是所有計算中最重要的一個運算門，並且可以延伸出 COPY、NOT 和 SWAP\n三種操作：\n\n\n\n\n\n\n\n\nCOPY\nNOT\nSWAP\n\n\n\n\n\n\n\n\n\n\nCCNOT (Toffoli Gate)\nCCNOT 門的運作如下：\n\n\nCCNOT Gate\n\n\na = 0, b = 0 ⟹ ab = 0 ⟹ |c⊕ab⟩=|c ⊕ 0⟩ = |c⟩\n\n\nCCNOT 性質：\n\n\nCCNOT Reversibility\n\nCCNOT ⋅ CCNOT = I\nCCNOT−1 ⋅ CCNOT = I\nCCNOT−1 = CCNOT\n邏輯運算門\nAND\nAND 的運作如下：\n\n\nAND Gate\n\nXOR\nXOR 的運作如下：\n\n\nXOR Gate\n\nNAND (NOT AND)\nNAND 的運作如下：\n\n\nNAND Gate\n\nNOT\nNOT 也可以用 CNOT 的形式來表示：\n\n\nNOT Gate\n\nOR\nOR 的運作如下：\n\n\nOR Gate\n\n範例\n以下是量子電路的等價性：\n\n\nQuantum Circuit Equivalence\n\n\n量子傳輸\n量子演算法\nBernstein-Vazirani Algorithm\nSimon’s Algorithm\nShor’s Algorithm\nGrover’s Algorithm\nReferences\n\nShor’s\nAlgorithm - 量子計算初學者的理解\nHow Quantum Computers Break\nEncryption | Shor’s Algorithm Explained\n\n","tags":["quantum","hilbert-space","algorithms","physics"]},{"title":"Vue Basic Syntax","url":"/blog/2025/01/vue-basic-syntax/","content":"Vue Basic Syntax\nDirectives\n\nEvent Binding: v-on or shorthand\n@click\nAttribute Binding: v-bind or shorthand\n:attribute\n\nExamples: :input, :input.enter,\n:key\n\nTwo-Way Binding: v-model\nConditional Rendering:\n\nv-if\nv-else-if\nv-else\nv-show\n\nList Rendering: v-for\n\nExample: v-for=\"goal in goals\"\n\n\nCommunication Between\nComponents\n\nProps: Pass data from parent to child\nEmits: Send events from child to parent\n\n","tags":["tutorial","vue","syntax","basics","guide"]}]