[{"title":"在 macOS 使用 <bits/stdc++.h>","url":"/blog/2025/07/bits-std-on-mac/","content":"Steps\ncd /usr/local/includemkdir bitscd bitsvim stdc++.h\n在 stdc++.h 的檔案當中寫入下列資訊：\n// C++ includes used for precompiling -*- C++ -*-// Copyright (C) 2003-2014 Free Software Foundation, Inc.//// This file is part of the GNU ISO C++ Library.  This library is free// software; you can redistribute it and/or modify it under the// terms of the GNU General Public License as published by the// Free Software Foundation; either version 3, or (at your option)// any later version.// This library is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the// GNU General Public License for more details.// Under Section 7 of GPL version 3, you are granted additional// permissions described in the GCC Runtime Library Exception, version// 3.1, as published by the Free Software Foundation.// You should have received a copy of the GNU General Public License and// a copy of the GCC Runtime Library Exception along with this program;// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see// &lt;http://www.gnu.org/licenses/&gt;./** @file stdc++.h *  This is an implementation file for a precompiled header. */// 17.4.1.2 Headers// C#ifndef _GLIBCXX_NO_ASSERT#include &lt;cassert&gt;#endif#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;ciso646&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;cmath&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#if __cplusplus &gt;= 201103L#include &lt;ccomplex&gt;#include &lt;cfenv&gt;#include &lt;cinttypes&gt;#include &lt;cstdbool&gt;#include &lt;cstdint&gt;#include &lt;ctgmath&gt;#include &lt;cwchar&gt;#include &lt;cwctype&gt;#endif// C++#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;complex&gt;#include &lt;deque&gt;#include &lt;exception&gt;#include &lt;fstream&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;ios&gt;#include &lt;iosfwd&gt;#include &lt;iostream&gt;#include &lt;istream&gt;#include &lt;iterator&gt;#include &lt;limits&gt;#include &lt;list&gt;#include &lt;locale&gt;#include &lt;map&gt;#include &lt;memory&gt;#include &lt;new&gt;#include &lt;numeric&gt;#include &lt;ostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;stdexcept&gt;#include &lt;streambuf&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;#include &lt;utility&gt;#include &lt;valarray&gt;#include &lt;vector&gt;#if __cplusplus &gt;= 201103L#include &lt;array&gt;#include &lt;atomic&gt;#include &lt;chrono&gt;#include &lt;condition_variable&gt;#include &lt;forward_list&gt;#include &lt;future&gt;#include &lt;initializer_list&gt;#include &lt;mutex&gt;#include &lt;random&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;scoped_allocator&gt;#include &lt;system_error&gt;#include &lt;thread&gt;#include &lt;tuple&gt;#include &lt;typeindex&gt;#include &lt;type_traits&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#endif\n再來 #include &lt;bits/stdc++.h&gt; 就能順利運行了\nReferences\nmacOS\n下使用 &lt;bits/stdc++.h&gt;\n"},{"title":"Codeforces 暑期特訓：我想成為演算法大師 - Week 1","url":"/blog/2025/07/codeforces-algo-master-week-01/","content":"\nFrom LI2\nContests Group\n\nContest 09. Prefix sums\nand countings\n\nContenst\nProblems\n\nC. Rectangle Sum\n\nProblem\nGitHub\nSolution\n\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){    int n, m, k;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    vector &lt; vector &lt; int &gt; &gt; dp(n+1, vector &lt; int &gt; (m+1, 0));    for(int i=1; i&lt;=n; i++){        for(int j=1; j&lt;=m; j++){            cin &gt;&gt; dp[i][j];        }    }    for(int i=1; i&lt;=n; i++){        for(int j=1; j&lt;=m; j++){            dp[i][j] += dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1];        }    }    // for(int i=0; i&lt;=n; i++){    //     for(int j=0; j&lt;=m; j++){    //         cout &lt;&lt; dp[i][j] &lt;&lt; ' ';    //     }    //     cout &lt;&lt; endl;    // }    int x1, y1, x2 ,y2;    for(int i=0; i&lt;k; i++){        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;        cout &lt;&lt; dp[x2][y2] - dp[x2][y1-1] - dp[x1-1][y2] + dp[x1-1][y1-1] &lt;&lt; endl;    }}\nF. Counting Sort\n\nProblem\nGitHub\nSolution\n\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){    vector &lt; int &gt; arr;    int n;    while(cin &gt;&gt; n){        arr.push_back(n);    }    n = arr.size();    vector &lt; int &gt; brr(101, 0);    for(int i=0; i&lt;n; i++){        brr[arr[i]]++;    }    for(int i=0; i&lt;=100; i++){        for(int j=0; j&lt;brr[i]; j++){            cout &lt;&lt; i &lt;&lt; ' ';        }    }}\nG. Haybale Stacking\n\nProblem\nGitHub\nSolution\n\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){    int n, k;    cin &gt;&gt; n &gt;&gt; k;    vector &lt; int &gt; arr(n, 0);    int a, b;    for(int i=0; i&lt;k; i++){        cin &gt;&gt; a &gt;&gt; b;        arr[a-1]++;        arr[b]--;    }    for(int i=1; i&lt;n; i++){        arr[i] += arr[i-1];    }    for(int i=0; i&lt;n; i++){        cout &lt;&lt; arr[i] &lt;&lt; ' ';    }}\nContest 10. Sorting\n\nContenst\nProblems\n\nC. Sorting halves\n\nProblem\nGitHub\nSolution\n\n#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;vector&gt;// #include &lt;algorithm&gt;using namespace std;int main(){    ifstream fcin(\"input.txt\");    ofstream fcout(\"output.txt\");    int n;    // cin &gt;&gt; n;    fcin &gt;&gt; n;    vector &lt; int &gt; arr(n);    for(int i=0; i&lt;n; i++){        // cin &gt;&gt; arr[i];        fcin &gt;&gt; arr[i];    }    sort(arr.begin(), arr.begin() + n/2);    // sort(arr.begin() + n/2, arr.end(), greater&lt;int&gt;());    sort(arr.begin() + n/2, arr.end(), [](int a, int b){        return a &gt; b;    });    for(int i=0; i&lt;n; i++){        // cout &lt;&lt; arr[i] &lt;&lt; ' ';        fcout &lt;&lt; arr[i] &lt;&lt; ' ';    }}\nD. Merge Lists\n\nProblem\nGitHub\nSolution\n\n#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;vector&gt;// #include &lt;sstream&gt;using namespace std;int main(){    ifstream fcin(\"input.txt\");    ofstream fcout(\"output.txt\");    int n;    string line;    vector &lt; int &gt; arr;    vector &lt; int &gt; brr;    getline(fcin, line);    stringstream ss(line);    while(ss &gt;&gt; n){        arr.push_back(n);    }    getline(fcin, line);    ss.clear();    ss.str(line);    while(ss &gt;&gt; n){        brr.push_back(n);    }    // for(int i: arr){    //     cout &lt;&lt; i &lt;&lt; ' ';    // }    // cout &lt;&lt; endl;    // for(int i: brr){    //     cout &lt;&lt; i &lt;&lt; ' ';    // }    // cout &lt;&lt; endl;    vector &lt; int &gt; crr;    int n1 = arr.size();    int n2 = brr.size();    int j = 0;    for(int i=0; i&lt;n1; i++){        while(arr[i]&gt;brr[j] and j&lt;n2){            crr.push_back(brr[j]);            j++;        }        crr.push_back(arr[i]);    }    while(j&lt;n2){        crr.push_back(brr[j]);        j++;    }    for(int i: crr){        fcout &lt;&lt; i &lt;&lt; ' ';    }}\nF. Sorting. Stone method.\n\nProblem\nGitHub\nSolution\n\n#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;vector&gt;using namespace std;int main(){    ifstream fcin(\"input.txt\");    ofstream fcout(\"output.txt\");    int n;    fcin &gt;&gt; n;    vector &lt; int &gt; arr(n);    for(int i=0; i&lt;n; i++){        fcin &gt;&gt; arr[i];    }    bool det = true;    for(int i=n-1; i&gt;0; i--){        for(int j=0; j&lt;i; j++){            if(arr[j]&gt;arr[j+1]){                swap(arr[j], arr[j+1]);                det = false;                for(int k: arr){                    fcout &lt;&lt; k &lt;&lt; ' ';                }                fcout &lt;&lt; endl;            }        }    }    if(det){        fcout &lt;&lt; 0;    }}\nK. Olympiad Results\n\nProblem\nGitHub\nSolution\n\n#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;vector&gt;using namespace std;int main(){    ifstream fcin(\"input.txt\");    ofstream fcout(\"output.txt\");    int n;    fcin &gt;&gt; n;    int a, b;    vector &lt; pair &lt; int, int &gt; &gt; arr(n);    for(int i=0; i&lt;n; i++){        fcin &gt;&gt; a &gt;&gt; b;        arr[i] = make_pair(a, b);    }    sort(arr.begin(), arr.end(), [](pair &lt; int, int &gt; p1, pair &lt; int, int &gt; p2){        if(p1.second == p2.second){            return p1.first &lt; p2.first;        }else{            return p1.second &gt; p2.second;        }    });    for(auto i: arr){        fcout &lt;&lt; i.first &lt;&lt; ' ' &lt;&lt; i.second &lt;&lt; endl;    }}\n","tags":["algorithm","codeforces","competitive-programming"]},{"title":"Codeforces 暑期特訓：我想成為演算法大師 - Week 2","url":"/blog/2025/07/codeforces-algo-master-week-02/","content":"\nFrom LI2\nContests Group\n\nContest 11. Binary Search\n\nContenst\nProblems\n\nC. Street with monuments\n\nProblem\nGitHub\nSolution\n\n用 upper_bound() 找第一個大於目標\ntarget=d[i]+r 的元素\nvoid solve() {    int n, r;    cin &gt;&gt; n &gt;&gt; r;    vector&lt;int&gt;d(n);    FOR(i, 0, n) cin &gt;&gt; d[i];    int ans = 0;    FOR(i, 0, n){        auto it_upper = upper_bound(ALL(d), d[i]+r);        ans += d.end()-it_upper;    }    cout &lt;&lt; ans &lt;&lt; endl;}\n* 記得開 long long\nE. Diplomas\n\nProblem\nGitHub\nSolution\n\n如果答案邊長是 ans ，那麼邊長為 ans+1\n也會成立，所以目標是用 binary_search 找到最小的邊長\nvoid solve() {    int w, h, n;    cin &gt;&gt; w &gt;&gt; h &gt;&gt; n;    int l = 1;    int r = max(w, h) * n;    int ans = r;    while(l&lt;=r){        int mid = l + (r-l)/2;        int cnt = ((int)mid/w) * ((int)mid/h);        if(cnt &gt;= n){            ans = mid;            r = mid - 1;        }else{            l = mid + 1;        }    }    cout &lt;&lt; ans &lt;&lt; endl;}\nJ. Forest Clearing\n\nProblem\nGitHub Solution\n\n用 binary_search 找最少能砍完的天數\n記得開long long，其中\ny += a * (mid - mid / k); 及\ny += b * (mid - mid / m); 可能會卡在 WA，因為 109 × 1018 = 1027\n會溢位。\nvoid solve() {    int a, k, b, m, x;    cin &gt;&gt; a &gt;&gt; k &gt;&gt; b &gt;&gt; m &gt;&gt; x;    int l = 1;    int r = 2 * x;    int ans = r;    while(l&lt;=r){        int mid = l + (r-l) / 2;        int y = 0;        if((mid - mid / k) &gt; x / a){            y = x + 1;        }else{            y += a * (mid - mid / k);        }        if((mid - mid / m) &gt; x / b){            y = x + 1;        }else{            y += b * (mid - mid / m);        }        if(y&gt;=x){            r = mid - 1;            ans = mid;        }else{            l = mid + 1;        }    }    cout &lt;&lt; ans &lt;&lt; endl;}\nContest 13. Recursion\n\nContenst\nProblems\n\nC. Transformations\n\nProblem\nGitHub Solution\n\nBFS 從 b 每次做 -1 或 /2\n的動作推到 a 其中 queue q 是存 BFS\n路徑的節點，再用 map prev 、 op\n存經過每個數字的下個點及做得動作，最後 now 從\na 跑到 b，再將答案的等式做出來。\nvoid solve() {    int a, b;    cin &gt;&gt; a &gt;&gt; b;    queue &lt; int &gt; q;    map &lt; int, int &gt; prev;    map &lt; int, char &gt; op;    q.push(b);    prev[b] = 0;    op[b] = ' ';    while(!q.empty()){        int c = q.front();        q.pop();        if(c==a) break;        int next = c - 1;        if(next&gt;=a and prev.find(next)==prev.end()){            q.push(next);            prev[next] = c;            op[next] = '+';        }        if(c%2==0){            next = c / 2;            if(next&gt;=a and prev.find(next)==prev.end()){                q.push(next);                prev[next] = c;                op[next] = '*';            }        }    }    string ans = to_string(a);    int now = a;    while(now!=b){        if(op[now]=='+'){            ans = \"(\" + ans + \" + 1)\";        }else{            ans = ans + \" * 2\";        }        now = prev[now];    }    cout &lt;&lt; b &lt;&lt; \" = \" &lt;&lt; ans &lt;&lt; endl;}\nE. Weighing\n\nProblem\nGitHub Solution\n\nL. Peaceful Queens\n\nProblem\nGitHub Solution\n\n","tags":["algorithm","codeforces","competitive-programming"]},{"title":"Docker - Ubuntu SSH Setup","url":"/blog/2024/11/docker-ubuntu-ssh-setup/","content":"Docker - Ubuntu SSH Setup\nHost: Use the same port -&gt; just change to the SSH\nport that does not conflict with NAS.\nEnvironment Settings\nfor Ubuntu Container\nDockerfile\nFROM ubuntu:latestRUN apt-get update &amp;&amp; apt-get install -y openssh-serverRUN mkdir /var/run/sshdRUN echo 'root:your_password' | chpasswdRUN sed -i 's/PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_configRUN sed 's@session\\s*required\\s*pam_loginuid.so@session optional pam_loginuid.so@g' -i /etc/pam.d/sshd# Other installationsRUN apt-get upgrade -yRUN apt-get install -y sudo nano vim curl gitEXPOSE 22CMD [\"/usr/sbin/sshd\", \"-D\"]\nDocker Build and Push to\nDocker Hub\ndocker build -t ubuntu_ssh .docker tag ubuntu_ssh wulukewu/ubuntu_ssh:latestdocker push wulukewu/ubuntu_ssh:latest\nInstall OpenSSH-Server\napt-get update apt-get install -y openssh-servermkdir /var/run/sshdecho 'root:your_password' | chpasswdsed -i 's/PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_configsed 's@session\\s*required\\s*pam_loginuid.so@session optional pam_loginuid.so@g' -i /etc/pam.d/sshd/usr/sbin/sshd -D\n\nPull and Run the ubuntu_ssh\nImage\nPull ubuntu_ssh from Docker\nHub\nsudo docker pull wulukewu/ubuntu_ssh:latest\nRun ubuntu_ssh in Host\nsudo docker run -d --net=host --name ubuntu_ssh wulukewu/ubuntu_ssh:latest\nAccess the Ubuntu Container\nsudo docker exec -i -t ubuntu_ssh /bin/bash\n\nHostname Configuration\nChange Hostname\nsudo nano /etc/hostnamesudo nano /etc/hostssudo reboot\nDisplay the Current Hostname\nhostname\n\nSSH Configuration\nChange SSH Port\nsudo nano /etc/ssh/sshd_configservice ssh restart\n\nUser Management\nAdd a New Sudo User\nadduser user_name\nAdd the User to the Sudo\nGroup\nusermod -aG sudo user_nameusermod -aG root user_name\nChange User Password\nsudo passwd user_name\nTest Sudo Access\nsu - user_name\n\nReferences\n\nHow\nto SSH into a Docker Container | Step-by-Step Tutorial\nSave\nDocker Image as a File\nUbuntu\nLinux Change Hostname\nDay 21:\nIntroduction to Docker Networking (Part 2)\nDocker\nBasic Commands Cheat Sheet\nHow\nto Create a New Sudo-Enabled User on Ubuntu\nChange\nPassword for Root and User Accounts\nAsk\nChatGPT\n\n","tags":["docker","ubuntu","ssh","devops","containerization","linux","tutorial"]},{"title":"設定GitHub SSH金鑰","url":"/blog/2024/11/github-ssh-key/","content":"Setup\n\n根據email創建一個新的SSH金鑰\nssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"\n開啟ssh-agent，將私鑰加入到ssh-agent\neval \"$(ssh-agent -s)\"ssh-add -K ~/.ssh/id_rsa\n上傳公鑰，並到GitHub上上傳SSH key\ncat ~/.ssh/id_rsa.pub GitHub Keys Settings \nssh連接GitHub SSH ssh -T git@github.com\n\nResources\n\n設定 Github\nSSH 金鑰 feat. Github SSH、HTTPS 的差異\nHow to clone, push, and pull\nwith git (beginners GitHub tutorial)\n\n","tags":["ssh","tutorial","github","git","setup"]},{"title":"量子計算基礎 - 從單量子位到多量子位系統","url":"/blog/2025/04/quantum-system/","content":"大一下去修了一門量子計算的課，前面的概念跟線性代數有滿多相似的地方，後半部分才真正開始講量子演算法。\n量子計算基礎簡介\n量子電腦與傳統電腦的差別，在於傳統電腦儲存資訊的最小單位是位元（bit），量子電腦則是使用量子位元（qubit）。位元可以存在一種狀態，1\n或是 0。量子位元特別的地方是，它在一個時間，可以同時是 1 也是 0。\n\n\nbit vs qubit\n\n量子在通訊上有很高的安全性，利用量子力學原理，能夠在兩方之間安全地分發加密密鑰。任何試圖竊聽的行為都會擾亂量子態，被接收方檢測到。\n\n\nquantum application\n\n過去超大整數的質因數分解，即使傳統超級電腦的運算能力也無法在短時間破解。不過，量子演算法（Shor’s\nAlgorithm，可解質因數分解）能在合理時間內完成破解，會顛覆現在 RSA\n等加密算法。\nClassical v.s. Quantum\n拆解質數\n現在有個數字 N = f1 × f2，由\nf1, f2\n兩個很大的質數構成。破解 RSA 的核心，就是從 N 找出 f1 和 f2。\n想要找到 N\n的因數，只要不斷給定 g，透過\nEuclid’s Algorithm（歐幾里得演算法，又稱輾轉相除法）快速計算判斷，當\ng 使得公因數 gcd (N,g) = a &gt; 1\n時，對於 RSA 來說就已經結束了。\n但要找到 g\n可以滿足上述條件其實並不容易，事實上真的只能一個一個猜 g\n是多少。不過，我們可以將這個隨機猜測的數字 g 轉換成很有可能滿足條件的 gp/2 ± 1。\n\n\n為什麼是 gp/2 ± 1 ？\n\n若給定兩個數 A, B，且 gcd (A,B) = 1，則存在一個正整數\np 使得 Ap = m ⋅ B + 1，其中\nm\n為某個整數（根據歐拉定理）。\n舉兩個例子來說：\nEx1\n給定 (A,B) = (7,15)，則：\n\nEx2\n給定 (A,B) = (42,13)，則：\n\n因此，m ⋅ B = Ap − 1 = (Ap/2+1)(Ap/2−1)\n\n將機會不大的數字 g 轉換成很有可能的gp/2 ± 1，只要找到這樣的p就好（p要是偶數才能真正拆解喔！）\nClassical\n我們用個例子來想，要用傳統電腦找到一個 p 使得 42p = m × 13 + 1，可能會從\np = 1, 2, 3, …\n開始一個一個慢慢代入判斷，但如果現在給定 gp = m × N + 1\n的 g 和 N 都很大呢？\n對傳統電腦來說，就真的只能一個一個數字慢慢算，直到找到答案為止，這也就是為什麼現在能夠這麼廣泛地使用\nRSA 加密。但是對量子電腦來說就不太一樣了……\nQuantum\n用量子來計算的好處是因為有疊加態（superposition）。\n我們可以構建一個 f(x) 的函數。若要計算 a, b, c, d\n各自的函數值，對於傳統電腦來說，就是一個一個代入計算：\nf(a),  f(b),  f(c),  f(d)\n但在量子的世界，可以讓一個或多個量子位元處於疊加態：\n|a⟩+|b⟩ + |c⟩+|d⟩\n然後將這個疊加態輸入設計好的 f(x)\n邏輯閘做平行運算，得到：\n|f(a)⟩+|f(b)⟩ + |f(c)⟩+|f(d)⟩\n\n到這邊還需要先知道另一個 Shor’s Algorithm\n的核心概念。一樣目標是找到滿足條件的 p。如果現在隨便找的一個 x，會得到 gx = mN + r，其中\nr 是餘數，那麼很容易證明 gx + p = m2N + r\n也成立。\n換句話說，對於某個週期 p，gx 模 N 的餘數會重複出現：\ngx mod  N = r ⟹ gx + p mod  N = r\n這個「週期性」就是 Shor’s Algorithm\n能有效率分解質因數的關鍵。只要能找到這個週期 p，就能透過 Quantum Fourier\nTransform（量子傅立葉變換）進一步拆解 N。\n\n\nquantum fourier transform\n\n\n前面提到，在量子的世界中，我們可以構建量子閘，讓所有輸入 x 的餘數 r 同時被計算出來：\n|x⟩→|x⟩|gx mod  N⟩\n這表示，當量子位元處於疊加態時，經過適當設計的量子閘後，所有 x 對應的 gx mod  N\n都會同時存在於量子態中。\n\n\nquantum shor process\n\n從這些餘數當中，任取一個 r，可以經由適當的轉換，將其餘的\nx 都變成 0。最後透過 Fourier Transform 找出的 g = x 和 p，就可以利用前面提過的傳統方式，判斷\ngp/2 ± 1\n是否與 N 有公因數，將 N 拆解開來。\n\n\n標準的 2048 位元 RSA\n加密，就算用目前世界上最強的超級電腦（太湖之光，中國製），花費地球年齡的時間（46\n億年）都無法破解。\n\n如果量子電腦真的存在，能將運算時間由數十億年縮減為幾分、幾秒鐘，數字\nN 都能快速被拆解成 f1, f2\n兩個質數，現在的金融、通訊等都會受到嚴重的影響。但是現在還不需要擔心，因為目前的技術還沒辦法處理太多位元的數字，可能只能拆解\n15 = 3 × 5 這種容易的而已。\n\n單量子位系統\n(Single-Qubit Quantum Systems)\n在量子計算中，量子位元 (Qubit)\n是最基本的資訊單位，類似於傳統計算中的位元\n(Bit)。然而，與傳統位元只能處於 0 或 1 的狀態不同，量子位元可以同時處於\n0 和 1 的疊加態。先來介紹一下量子計算所處於的空間定義：\nHilbert 空間 (Hilbert Space)\n對於單量子位元系統，Hilbert 空間是一個複數 ℂ 中的 inner product\nspace，有向量加法、純量乘法，以及計算向量之間的內積。\n\nIf |ψ⟩,|ϕ⟩ ∈ V, α, β ∈ ℂ, then α|ψ⟩+β|ϕ⟩ ∈ V.\n\n在單量子位元系統當中，我們常用, 當作標準基底，而一個量子位元則可表示為 |ψ⟩=α|0⟩ + β|1⟩。\n至於維度 (Dimension) 為 N\n的向量空間，則會以 {|e1⟩,|e2⟩, …, |eN⟩}\n當作標準基底，也可以寫成{|0⟩,|1⟩, …, |N − 1⟩} 。\n\n\n正規化 (Normalized)：⟨e1|e1⟩=⟨e2|e2⟩ = … = ⟨eN|eN⟩ = 1\n正交 (Orthogoral)：⟨e1|e2⟩=⟨e2|e3⟩ = … = ⟨eN − 1|eN⟩ = 0\n\n因此：\n\nNote：單量子位元系統的 Hilbert 空間是一個 N = 2\n的簡單空間，而複數量子位元系統的 Hilbert\n空間維度會隨著量子位元數量增加而指數成長，例如 n = 5 個量子位元系統的 Hilbert\n空間維度為 N = 25 = 32。\n範例\n我們拿一個例子來說明好了，假設 , ，那麼可以做下列這幾個運算：\n對偶向量 (Dual Vector)\n\n\n\n\n內積 (Inner Product)\n\n\n\n\n因此：\n\n⟨v|v⟩ ∈ ℝ ≥ 0\n(non-negative real)\n\n(a⟨v2|+b⟨v3|)|v1⟩=a⟨v2|v1⟩ + b⟨v3|v1⟩\n\n向量範數 (Norm)\n\n正規化向量 (Normalized\nVector)\n量子態必須是正規化的，以保證測量結果的機率總和為 1。\n\n例如：\n\n計算內積：\n\n\n投影運算子 (Projection\nOperator)\n\n\n\n此時算出的  和  就分別是 |ψ⟩ 在 |e1⟩ 和 |e2⟩\n兩個基底的投影運算子。\n崩塌 (Collapse)\n我們前面說過，|ψ⟩=∑iαi|ei⟩\n是由N維的基底所組成的。其中\n|ei⟩ 在\n|ψ⟩ 出現的機率為 |αi|2，則|α1|2 + |α2|2 + … + |αN|2 = 1。\n在 |ψ⟩=∑iαi|ei⟩\n當中，|ei⟩\n出現的機率取決於 |αi|2，而此時的觀測是不可逆的。當測量完成後，量子態會崩塌到對應的基底態\n|ei⟩，並且無法回復到原本的疊加態。因此測量過程不可逆，且量子態的疊加性在測量後不復存在。\n\n\nQuantum Measurement Single\n\n範例\n\n\n|e1⟩ 在\n|ψ⟩ 出現的機率為 \n|e2⟩ 在\n|ψ⟩ 出現的機率為 \n\n\n量子態 (Quantum State)：\nPi|ψ⟩→|ei⟩\n|ψ⟩=α1|e1⟩ + α2|e2⟩\n經典態 (Classical State)：\n\n\n量子態在測量後會崩塌到某個基底態，而此時的經典態不再具有量子態的疊加性。\nBloch 球 (Bloch Sphere)\nBloch 球用於表示單量子位的狀態：video\n\n\nBloch Sphere\n\n\n\n|0⟩ → (0,0,1)\n|1⟩ → (0,0,−1)\n| + ⟩ → (1,0,0)\n| − ⟩ → (−1,0,0)\n|i⟩ → (0,1,0)\n| − i⟩ → (0,−1,0)\n\nBloch 球上的 I, X, Y, Z\n運算子幾何意義\n\nI (單位運算子)：不改變 Bloch\n球上的狀態（即不旋轉）。\nX 門（Pauli-X）：繞 x 軸旋轉 π 弧度（180°），將 |0⟩ 和 |1⟩\n互換。對應於 Bloch 球上的 x\n軸翻轉。\nY 門（Pauli-Y）：繞 y 軸旋轉 π 弧度（180°），將 |0⟩ 和 |1⟩\n互換，並帶有相位。對應於 Bloch 球上的 y 軸翻轉。\nZ 門（Pauli-Z）：繞 z 軸旋轉 π 弧度（180°），將 | + ⟩ 和 | − ⟩ 互換，|0⟩ 不變，|1⟩ 變號。對應於 Bloch 球上的 z 軸翻轉。\n\n簡單來說，X, Y, Z 分別對應於 Bloch 球上繞 x、y、z 軸的 180° 旋轉。\n\n多量子位系統\n(Multiple-Qubit Systems)\nHilbert 空間與張量積\n(Tensor Product)\n多量子位系統的 Hilbert 空間是單量子位空間的張量積：\nH2 ⊗ H2 ⊗ … ⊗ H2 = HN  (N\n個)\n假設：\n\n第 0 個 H2：{|0⟩0,|1⟩0}\n第 1 個 H2：{|0⟩1,|1⟩1}\n\nTensor Product\nH2 ⊗ H2:\n|ψ1⟩⊗|ψ0⟩ = [α1|0⟩1+β1|1⟩1] ⊗ [α0|0⟩0+β0|1⟩0]\n = α1α0|0⟩1⊗|0⟩0 + α1β0|0⟩1⊗|1⟩0 + β1α0|1⟩1⊗|0⟩0 + β1β0|1⟩1⊗|1⟩0\n = α1α0|00⟩10+α1β0|01⟩10 + β1α0|10⟩10+β1β0|11⟩10\n而此時：\n\n|0⟩1⊗|0⟩0 = |00⟩10\n|0⟩1⊗|1⟩0 = |01⟩10\n|1⟩1⊗|0⟩0 = |10⟩10\n|1⟩1⊗|1⟩0 = |11⟩10\n\n|00⟩,|01⟩, |10⟩,|11⟩ 為 H4 的基底\n範例\n假設：\n\n第 0 個 H2：, , T0 operator\n第 1 個 H2：, , T1 operator\n\n計算張量積：\n\n\n\n\n運算子與單元矩陣\n在多量子位系統中，運算子 T\n和單位運算子 I\n的結合可以用來描述量子態的演化。假設 T0 和 T1\n是作用於不同量子位的運算子，若它們相等，即 T0 = T1 = T，則可以簡化為單一運算子\nT 的作用。\n單位運算子 I\n的作用不會改變量子態，滿足以下關係：\nI|ψ⟩=|ψ⟩\n其中，單位運算子 I\n的矩陣形式為：\n\n當運算子 T\n作用於單一量子位的量子態時，可以表示為：\nT|ψ1⟩,|ψ0⟩\n而當運算子 T 與單位運算子\nI\n結合，作用於多量子位系統的張量積態時，則可以表示為：\n(T⊗I)(|ψ1⟩⊗|ψ0⟩)\n單位運算子：\n\n單元矩陣 (Unitary Matrix)\n假設 U ：\n\n則可發現 U−1 = U†\nNote：共軛轉置 (conjugate) U† = (U*)T\n\n\n\nU 是 Unitary Matrix\n\n量子門與狀態轉換\n(Quantum Gates and State Transformations)\n常見量子門\nH2\n的基本運算子為 I, X, Y, Z\n基本運算子 - X (NOT)\nX|0⟩=|1⟩,  X|1⟩=|0⟩\n\n其中：\nX2 = I = X−1X\nX−1 = X\n基本運算子 - Y\nY|0⟩=+i|1⟩,  Y|1⟩=−i|0⟩\n\n其中：\nY† = Y\n\nY2 = I\nY 是單元矩陣\n基本運算子 - Z\nZ|0⟩=|0⟩,  Z|1⟩=−|1⟩\n\n糾纏態與測量\n在H2中，\nU = αI + βX + γY + δZ\nBell State （貝爾態）\n\n\n\n\nBell State 是兩個 qubit 之間最純粹的糾纏態。\n假設：\n|ψ1⟩=α1|0⟩ + β1|1⟩,  |ψ0⟩ = α0|0⟩+β0|1⟩\n則它們的張量積\n|ψ1⟩⊗|ψ0⟩ = α1α0|00⟩+α1β0|01⟩ + β1α0|10⟩+β1β0|11⟩\n如果 β1α0 = α1β0 = 0，則為\n可分離態；否則為 糾纏態\n(entanglement)。\n糾纏測量\nα1α0|00⟩+β1β0|11⟩ ≠ |ψ1⟩⊗|ψ0⟩\n例如：\n|00⟩+|11⟩ = |0⟩1⊗|0⟩0 + |1⟩1⊗|1⟩0\n\n\nEntangled Measurement\n\n此時去做量子測量：\n\n第 1 個質點測量到 |0⟩，則第 0\n個質點就確定為 |0⟩\n第 1 個質點測量到 |1⟩，則第 0\n個質點就確定為 |1⟩\n\n\n\nQuantum Measurement Multiple\n\n逆向計算 (Reverse\nComputation)\nCNOT (Control NOT)\nCNOT 門的運作如下：\n\n\nCNOT Gate\n\n\nCNOT 性質：\nCNOT ⋅ CNOT = I\nCNOT−1 ⋅ CNOT = I\nCNOT−1 = CNOT\n舉個例子：\n\n\n\n\n\n\n\n1 ⊗ 0 = 1\n1 ⊗ 1 = 0\n\n\n\n\n\n\n\n\n\n這是所有計算中最重要的一個運算門，並且可以延伸出 COPY、NOT 和 SWAP\n三種操作：\n\n\n\n\n\n\n\n\nCOPY\nNOT\nSWAP\n\n\n\n\n\n\n\n\n\n\nCCNOT (Toffoli Gate)\nCCNOT 門的運作如下：\n\n\nCCNOT Gate\n\n\na = 0, b = 0 ⟹ ab = 0 ⟹ |c⊕ab⟩=|c ⊕ 0⟩ = |c⟩\n\n\nCCNOT 性質：\n\n\nCCNOT Reversibility\n\nCCNOT ⋅ CCNOT = I\nCCNOT−1 ⋅ CCNOT = I\nCCNOT−1 = CCNOT\n邏輯運算門\nAND\nAND 的運作如下：\n\n\nAND Gate\n\nXOR\nXOR 的運作如下：\n\n\nXOR Gate\n\nNAND (NOT AND)\nNAND 的運作如下：\n\n\nNAND Gate\n\nNOT\nNOT 也可以用 CNOT 的形式來表示：\n\n\nNOT Gate\n\nOR\nOR 的運作如下：\n\n\nOR Gate\n\n範例\n以下是量子電路的等價性：\n\n\nQuantum Circuit Equivalence\n\n\n量子傳輸\n量子演算法\nBernstein-Vazirani Algorithm\nSimon’s Algorithm\nShor’s Algorithm\nGrover’s Algorithm\nReferences\n\nShor’s\nAlgorithm - 量子計算初學者的理解\nHow Quantum Computers Break\nEncryption | Shor’s Algorithm Explained\n\n","tags":["quantum","hilbert-space","algorithms","physics"]},{"title":"Vue Basic Syntax","url":"/blog/2025/01/vue-basic-syntax/","content":"Vue Basic Syntax\nDirectives\n\nEvent Binding: v-on or shorthand\n@click\nAttribute Binding: v-bind or shorthand\n:attribute\n\nExamples: :input, :input.enter,\n:key\n\nTwo-Way Binding: v-model\nConditional Rendering:\n\nv-if\nv-else-if\nv-else\nv-show\n\nList Rendering: v-for\n\nExample: v-for=\"goal in goals\"\n\n\nCommunication Between\nComponents\n\nProps: Pass data from parent to child\nEmits: Send events from child to parent\n\n","tags":["tutorial","vue","syntax","basics","guide"]}]